// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: rpc.proto

package ptarmiganpb

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Field int32

const (
	VERSION Field = 0
	CREATE  Field = 1
	MOD     Field = 2
	VALUE   Field = 3
	LEASE   Field = 4
	KEY     Field = 5
)

var Field_name = map[int32]string{
	0: "VERSION",
	1: "CREATE",
	2: "MOD",
	3: "VALUE",
	4: "LEASE",
	5: "KEY",
}

var Field_value = map[string]int32{
	"VERSION": 0,
	"CREATE":  1,
	"MOD":     2,
	"VALUE":   3,
	"LEASE":   4,
	"KEY":     5,
}

func (x Field) String() string {
	return proto.EnumName(Field_name, int32(x))
}

func (Field) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{0}
}

// [FIELD] [COMPARISON] [VALUE]
type KVPredicate_Operator int32

const (
	// =
	EQUAL KVPredicate_Operator = 0
	// !=
	NOT_EQUAL KVPredicate_Operator = 1
	// >
	GT KVPredicate_Operator = 2
	// >=
	GTE KVPredicate_Operator = 3
	// <
	LT KVPredicate_Operator = 4
	// <=
	LTE         KVPredicate_Operator = 5
	STARTS_WITH KVPredicate_Operator = 6
)

var KVPredicate_Operator_name = map[int32]string{
	0: "EQUAL",
	1: "NOT_EQUAL",
	2: "GT",
	3: "GTE",
	4: "LT",
	5: "LTE",
	6: "STARTS_WITH",
}

var KVPredicate_Operator_value = map[string]int32{
	"EQUAL":       0,
	"NOT_EQUAL":   1,
	"GT":          2,
	"GTE":         3,
	"LT":          4,
	"LTE":         5,
	"STARTS_WITH": 6,
}

func (x KVPredicate_Operator) String() string {
	return proto.EnumName(KVPredicate_Operator_name, int32(x))
}

func (KVPredicate_Operator) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{2, 0}
}

type KVQueryRequest_SortOrder int32

const (
	NONE KVQueryRequest_SortOrder = 0
	ASC  KVQueryRequest_SortOrder = 1
	DESC KVQueryRequest_SortOrder = 2
)

var KVQueryRequest_SortOrder_name = map[int32]string{
	0: "NONE",
	1: "ASC",
	2: "DESC",
}

var KVQueryRequest_SortOrder_value = map[string]int32{
	"NONE": 0,
	"ASC":  1,
	"DESC": 2,
}

func (x KVQueryRequest_SortOrder) String() string {
	return proto.EnumName(KVQueryRequest_SortOrder_name, int32(x))
}

func (KVQueryRequest_SortOrder) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{3, 0}
}

type Condition_Quantifier int32

const (
	FOR_ALL Condition_Quantifier = 0
	EXISTS  Condition_Quantifier = 1
)

var Condition_Quantifier_name = map[int32]string{
	0: "FOR_ALL",
	1: "EXISTS",
}

var Condition_Quantifier_value = map[string]int32{
	"FOR_ALL": 0,
	"EXISTS":  1,
}

func (x Condition_Quantifier) String() string {
	return proto.EnumName(Condition_Quantifier_name, int32(x))
}

func (Condition_Quantifier) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{11, 0}
}

type Event_EventType int32

const (
	PUT    Event_EventType = 0
	DELETE Event_EventType = 1
)

var Event_EventType_name = map[int32]string{
	0: "PUT",
	1: "DELETE",
}

var Event_EventType_value = map[string]int32{
	"PUT":    0,
	"DELETE": 1,
}

func (x Event_EventType) String() string {
	return proto.EnumName(Event_EventType_name, int32(x))
}

func (Event_EventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{31, 0}
}

type PartitionRequestHeader struct {
	Store     string `protobuf:"bytes,1,opt,name=store,proto3" json:"store,omitempty"`
	Partition string `protobuf:"bytes,2,opt,name=partition,proto3" json:"partition,omitempty"`
	Replica   string `protobuf:"bytes,3,opt,name=replica,proto3" json:"replica,omitempty"`
}

func (m *PartitionRequestHeader) Reset()         { *m = PartitionRequestHeader{} }
func (m *PartitionRequestHeader) String() string { return proto.CompactTextString(m) }
func (*PartitionRequestHeader) ProtoMessage()    {}
func (*PartitionRequestHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{0}
}
func (m *PartitionRequestHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionRequestHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionRequestHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionRequestHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionRequestHeader.Merge(m, src)
}
func (m *PartitionRequestHeader) XXX_Size() int {
	return m.Size()
}
func (m *PartitionRequestHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionRequestHeader.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionRequestHeader proto.InternalMessageInfo

type ResponseHeader struct {
	// member_id is the ID of the member which sent the response.
	MemberId uint64 `protobuf:"varint,1,opt,name=member_id,json=memberId,proto3" json:"member_id,omitempty"`
}

func (m *ResponseHeader) Reset()         { *m = ResponseHeader{} }
func (m *ResponseHeader) String() string { return proto.CompactTextString(m) }
func (*ResponseHeader) ProtoMessage()    {}
func (*ResponseHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{1}
}
func (m *ResponseHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseHeader.Merge(m, src)
}
func (m *ResponseHeader) XXX_Size() int {
	return m.Size()
}
func (m *ResponseHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseHeader proto.InternalMessageInfo

type KVPredicate struct {
	// operator is the logical comparison operation for this comparison.
	Operator KVPredicate_Operator `protobuf:"varint,1,opt,name=operator,proto3,enum=ptarmiganpb.KVPredicate_Operator" json:"operator,omitempty"`
	// field is the key-value field to inspect for the comparison.
	Field Field `protobuf:"varint,2,opt,name=field,proto3,enum=ptarmiganpb.Field" json:"field,omitempty"`
	// Types that are valid to be assigned to Value:
	//	*KVPredicate_Int64
	//	*KVPredicate_Bytes
	Value isKVPredicate_Value `protobuf_oneof:"value"`
}

func (m *KVPredicate) Reset()         { *m = KVPredicate{} }
func (m *KVPredicate) String() string { return proto.CompactTextString(m) }
func (*KVPredicate) ProtoMessage()    {}
func (*KVPredicate) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{2}
}
func (m *KVPredicate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVPredicate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVPredicate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVPredicate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVPredicate.Merge(m, src)
}
func (m *KVPredicate) XXX_Size() int {
	return m.Size()
}
func (m *KVPredicate) XXX_DiscardUnknown() {
	xxx_messageInfo_KVPredicate.DiscardUnknown(m)
}

var xxx_messageInfo_KVPredicate proto.InternalMessageInfo

type isKVPredicate_Value interface {
	isKVPredicate_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type KVPredicate_Int64 struct {
	Int64 int64 `protobuf:"varint,3,opt,name=int64,proto3,oneof" json:"int64,omitempty"`
}
type KVPredicate_Bytes struct {
	Bytes []byte `protobuf:"bytes,4,opt,name=bytes,proto3,oneof" json:"bytes,omitempty"`
}

func (*KVPredicate_Int64) isKVPredicate_Value() {}
func (*KVPredicate_Bytes) isKVPredicate_Value() {}

func (m *KVPredicate) GetValue() isKVPredicate_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *KVPredicate) GetInt64() int64 {
	if x, ok := m.GetValue().(*KVPredicate_Int64); ok {
		return x.Int64
	}
	return 0
}

func (m *KVPredicate) GetBytes() []byte {
	if x, ok := m.GetValue().(*KVPredicate_Bytes); ok {
		return x.Bytes
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*KVPredicate) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*KVPredicate_Int64)(nil),
		(*KVPredicate_Bytes)(nil),
	}
}

type KVQueryRequest struct {
	Header PartitionRequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	// Only keys matching the predicates in the selection will be included in the result
	Selection []KVPredicate `protobuf:"bytes,2,rep,name=selection,proto3" json:"selection"`
	// Use after to get the next page of results by inserting the after cursor from the
	// previous page.
	After string `protobuf:"bytes,3,opt,name=after,proto3" json:"after,omitempty"`
	// limit is the limit on the number of keys returned in the result.
	// If limit is set to 0 the default limit is used.
	Limit int64 `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
	// revision is the revision of the store to use for the query.
	// If revision is less or equal to zero, the range is over the newest key-value store.
	// If the revision has been compacted, ErrCompacted is returned as a response.
	Revision int64 `protobuf:"varint,5,opt,name=revision,proto3" json:"revision,omitempty"`
	// sort_order is the order for returned sorted results.
	SortOrder KVQueryRequest_SortOrder `protobuf:"varint,6,opt,name=sort_order,json=sortOrder,proto3,enum=ptarmiganpb.KVQueryRequest_SortOrder" json:"sort_order,omitempty"`
	// sort_target is the key-value field to use for sorting.
	SortTarget Field `protobuf:"varint,7,opt,name=sort_target,json=sortTarget,proto3,enum=ptarmiganpb.Field" json:"sort_target,omitempty"`
	// serializable sets the range request to use serializable member-local reads.
	// Range requests are linearizable by default; linearizable requests have higher
	// latency and lower throughput than serializable requests but reflect the current
	// consensus of the cluster. For better performance, in exchange for possible stale reads,
	// a serializable range request is served locally without needing to reach consensus
	// with other nodes in the cluster.
	Serializable bool `protobuf:"varint,8,opt,name=serializable,proto3" json:"serializable,omitempty"`
	// exclude_values when set excludes values from the resulting kvs
	ExcludeValues bool `protobuf:"varint,9,opt,name=exclude_values,json=excludeValues,proto3" json:"exclude_values,omitempty"`
	// include_count when set includes the total count of keys matching
	// the query constraints in the result
	IncludeCount bool `protobuf:"varint,10,opt,name=include_count,json=includeCount,proto3" json:"include_count,omitempty"`
}

func (m *KVQueryRequest) Reset()         { *m = KVQueryRequest{} }
func (m *KVQueryRequest) String() string { return proto.CompactTextString(m) }
func (*KVQueryRequest) ProtoMessage()    {}
func (*KVQueryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{3}
}
func (m *KVQueryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVQueryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVQueryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVQueryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVQueryRequest.Merge(m, src)
}
func (m *KVQueryRequest) XXX_Size() int {
	return m.Size()
}
func (m *KVQueryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_KVQueryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_KVQueryRequest proto.InternalMessageInfo

type KVQueryResponse struct {
	Header ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	// kvs is the list of key-value pairs matched by the query.
	Kvs []KeyValue `protobuf:"bytes,2,rep,name=kvs,proto3" json:"kvs"`
	// more indicates if there are more keys matching the query.
	More bool `protobuf:"varint,3,opt,name=more,proto3" json:"more,omitempty"`
	// after is a cursor that can be used in to get the next page
	// of results after this one.
	After string `protobuf:"bytes,4,opt,name=after,proto3" json:"after,omitempty"`
	// count is set to the total number of keys matching the query.
	Count int64 `protobuf:"varint,5,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *KVQueryResponse) Reset()         { *m = KVQueryResponse{} }
func (m *KVQueryResponse) String() string { return proto.CompactTextString(m) }
func (*KVQueryResponse) ProtoMessage()    {}
func (*KVQueryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{4}
}
func (m *KVQueryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVQueryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVQueryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVQueryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVQueryResponse.Merge(m, src)
}
func (m *KVQueryResponse) XXX_Size() int {
	return m.Size()
}
func (m *KVQueryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_KVQueryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_KVQueryResponse proto.InternalMessageInfo

type KVPutRequest struct {
	Header PartitionRequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	// Only keys matching the predicates in the selection will be updated
	Selection []KVPredicate `protobuf:"bytes,2,rep,name=selection,proto3" json:"selection"`
	// key is the key, in bytes, to create or update. Selection is ignored
	// if key is specified
	Key []byte `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	// value is the value, in bytes, to associate with the key in the key-value store.
	Value []byte `protobuf:"bytes,4,opt,name=value,proto3" json:"value,omitempty"`
	// lease is the lease ID to associate with the key in the key-value store. A lease
	// value of 0 indicates no lease.
	Lease int64 `protobuf:"varint,5,opt,name=lease,proto3" json:"lease,omitempty"`
	// If prev_kv is set, ptarmigan gets the previous key-value pair before changing it.
	// The previous key-value pair will be returned in the put response.
	PrevKv bool `protobuf:"varint,6,opt,name=prev_kv,json=prevKv,proto3" json:"prev_kv,omitempty"`
	// If ignore_value is set, ptarmigan updates the key using its current value.
	// Returns an error if the key does not exist.
	IgnoreValue bool `protobuf:"varint,7,opt,name=ignore_value,json=ignoreValue,proto3" json:"ignore_value,omitempty"`
	// If ignore_lease is set, ptarmigan updates the key using its current lease.
	// Returns an error if the key does not exist.
	IgnoreLease bool `protobuf:"varint,8,opt,name=ignore_lease,json=ignoreLease,proto3" json:"ignore_lease,omitempty"`
}

func (m *KVPutRequest) Reset()         { *m = KVPutRequest{} }
func (m *KVPutRequest) String() string { return proto.CompactTextString(m) }
func (*KVPutRequest) ProtoMessage()    {}
func (*KVPutRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{5}
}
func (m *KVPutRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVPutRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVPutRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVPutRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVPutRequest.Merge(m, src)
}
func (m *KVPutRequest) XXX_Size() int {
	return m.Size()
}
func (m *KVPutRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_KVPutRequest.DiscardUnknown(m)
}

var xxx_messageInfo_KVPutRequest proto.InternalMessageInfo

type KVPutResponse struct {
	Header ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	// if prev_kv is set in the request, the previous key-value pairs will be returned.
	PrevKvs []KeyValue `protobuf:"bytes,2,rep,name=prev_kvs,json=prevKvs,proto3" json:"prev_kvs"`
}

func (m *KVPutResponse) Reset()         { *m = KVPutResponse{} }
func (m *KVPutResponse) String() string { return proto.CompactTextString(m) }
func (*KVPutResponse) ProtoMessage()    {}
func (*KVPutResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{6}
}
func (m *KVPutResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVPutResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVPutResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVPutResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVPutResponse.Merge(m, src)
}
func (m *KVPutResponse) XXX_Size() int {
	return m.Size()
}
func (m *KVPutResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_KVPutResponse.DiscardUnknown(m)
}

var xxx_messageInfo_KVPutResponse proto.InternalMessageInfo

type KVDeleteRequest struct {
	Header PartitionRequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	// Only keys matching the predicates in the selection will be deleted
	Selection []KVPredicate `protobuf:"bytes,2,rep,name=selection,proto3" json:"selection"`
	// If prev_kv is set, ptarmigan gets the previous key-value pairs before deleting it.
	// The previous key-value pairs will be returned in the delete response.
	PrevKv bool `protobuf:"varint,3,opt,name=prev_kv,json=prevKv,proto3" json:"prev_kv,omitempty"`
}

func (m *KVDeleteRequest) Reset()         { *m = KVDeleteRequest{} }
func (m *KVDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*KVDeleteRequest) ProtoMessage()    {}
func (*KVDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{7}
}
func (m *KVDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVDeleteRequest.Merge(m, src)
}
func (m *KVDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *KVDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_KVDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_KVDeleteRequest proto.InternalMessageInfo

type KVDeleteResponse struct {
	Header ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	// deleted is the number of keys deleted by the delete range request.
	Deleted int64 `protobuf:"varint,2,opt,name=deleted,proto3" json:"deleted,omitempty"`
	// if prev_kv is set in the request, the previous key-value pairs will be returned.
	PrevKvs []KeyValue `protobuf:"bytes,3,rep,name=prev_kvs,json=prevKvs,proto3" json:"prev_kvs"`
}

func (m *KVDeleteResponse) Reset()         { *m = KVDeleteResponse{} }
func (m *KVDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*KVDeleteResponse) ProtoMessage()    {}
func (*KVDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{8}
}
func (m *KVDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVDeleteResponse.Merge(m, src)
}
func (m *KVDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *KVDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_KVDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_KVDeleteResponse proto.InternalMessageInfo

type KVRequestOp struct {
	// request is a union of request types accepted by a transaction.
	//
	// Types that are valid to be assigned to Request:
	//	*KVRequestOp_RequestQuery
	//	*KVRequestOp_RequestPut
	//	*KVRequestOp_RequestDelete
	//	*KVRequestOp_RequestTxn
	Request isKVRequestOp_Request `protobuf_oneof:"request"`
}

func (m *KVRequestOp) Reset()         { *m = KVRequestOp{} }
func (m *KVRequestOp) String() string { return proto.CompactTextString(m) }
func (*KVRequestOp) ProtoMessage()    {}
func (*KVRequestOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{9}
}
func (m *KVRequestOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVRequestOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVRequestOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVRequestOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVRequestOp.Merge(m, src)
}
func (m *KVRequestOp) XXX_Size() int {
	return m.Size()
}
func (m *KVRequestOp) XXX_DiscardUnknown() {
	xxx_messageInfo_KVRequestOp.DiscardUnknown(m)
}

var xxx_messageInfo_KVRequestOp proto.InternalMessageInfo

type isKVRequestOp_Request interface {
	isKVRequestOp_Request()
	MarshalTo([]byte) (int, error)
	Size() int
}

type KVRequestOp_RequestQuery struct {
	RequestQuery *KVQueryRequest `protobuf:"bytes,1,opt,name=request_query,json=requestQuery,proto3,oneof" json:"request_query,omitempty"`
}
type KVRequestOp_RequestPut struct {
	RequestPut *KVPutRequest `protobuf:"bytes,2,opt,name=request_put,json=requestPut,proto3,oneof" json:"request_put,omitempty"`
}
type KVRequestOp_RequestDelete struct {
	RequestDelete *KVDeleteRequest `protobuf:"bytes,3,opt,name=request_delete,json=requestDelete,proto3,oneof" json:"request_delete,omitempty"`
}
type KVRequestOp_RequestTxn struct {
	RequestTxn *KVTxnRequest `protobuf:"bytes,4,opt,name=request_txn,json=requestTxn,proto3,oneof" json:"request_txn,omitempty"`
}

func (*KVRequestOp_RequestQuery) isKVRequestOp_Request()  {}
func (*KVRequestOp_RequestPut) isKVRequestOp_Request()    {}
func (*KVRequestOp_RequestDelete) isKVRequestOp_Request() {}
func (*KVRequestOp_RequestTxn) isKVRequestOp_Request()    {}

func (m *KVRequestOp) GetRequest() isKVRequestOp_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *KVRequestOp) GetRequestQuery() *KVQueryRequest {
	if x, ok := m.GetRequest().(*KVRequestOp_RequestQuery); ok {
		return x.RequestQuery
	}
	return nil
}

func (m *KVRequestOp) GetRequestPut() *KVPutRequest {
	if x, ok := m.GetRequest().(*KVRequestOp_RequestPut); ok {
		return x.RequestPut
	}
	return nil
}

func (m *KVRequestOp) GetRequestDelete() *KVDeleteRequest {
	if x, ok := m.GetRequest().(*KVRequestOp_RequestDelete); ok {
		return x.RequestDelete
	}
	return nil
}

func (m *KVRequestOp) GetRequestTxn() *KVTxnRequest {
	if x, ok := m.GetRequest().(*KVRequestOp_RequestTxn); ok {
		return x.RequestTxn
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*KVRequestOp) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*KVRequestOp_RequestQuery)(nil),
		(*KVRequestOp_RequestPut)(nil),
		(*KVRequestOp_RequestDelete)(nil),
		(*KVRequestOp_RequestTxn)(nil),
	}
}

type KVResponseOp struct {
	// response is a union of response types returned by a transaction.
	//
	// Types that are valid to be assigned to Response:
	//	*KVResponseOp_ResponseQuery
	//	*KVResponseOp_ResponsePut
	//	*KVResponseOp_ResponseDelete
	//	*KVResponseOp_ResponseTxn
	Response isKVResponseOp_Response `protobuf_oneof:"response"`
}

func (m *KVResponseOp) Reset()         { *m = KVResponseOp{} }
func (m *KVResponseOp) String() string { return proto.CompactTextString(m) }
func (*KVResponseOp) ProtoMessage()    {}
func (*KVResponseOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{10}
}
func (m *KVResponseOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVResponseOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVResponseOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVResponseOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVResponseOp.Merge(m, src)
}
func (m *KVResponseOp) XXX_Size() int {
	return m.Size()
}
func (m *KVResponseOp) XXX_DiscardUnknown() {
	xxx_messageInfo_KVResponseOp.DiscardUnknown(m)
}

var xxx_messageInfo_KVResponseOp proto.InternalMessageInfo

type isKVResponseOp_Response interface {
	isKVResponseOp_Response()
	MarshalTo([]byte) (int, error)
	Size() int
}

type KVResponseOp_ResponseQuery struct {
	ResponseQuery *KVQueryResponse `protobuf:"bytes,1,opt,name=response_query,json=responseQuery,proto3,oneof" json:"response_query,omitempty"`
}
type KVResponseOp_ResponsePut struct {
	ResponsePut *KVPutResponse `protobuf:"bytes,2,opt,name=response_put,json=responsePut,proto3,oneof" json:"response_put,omitempty"`
}
type KVResponseOp_ResponseDelete struct {
	ResponseDelete *KVDeleteResponse `protobuf:"bytes,3,opt,name=response_delete,json=responseDelete,proto3,oneof" json:"response_delete,omitempty"`
}
type KVResponseOp_ResponseTxn struct {
	ResponseTxn *KVTxnResponse `protobuf:"bytes,4,opt,name=response_txn,json=responseTxn,proto3,oneof" json:"response_txn,omitempty"`
}

func (*KVResponseOp_ResponseQuery) isKVResponseOp_Response()  {}
func (*KVResponseOp_ResponsePut) isKVResponseOp_Response()    {}
func (*KVResponseOp_ResponseDelete) isKVResponseOp_Response() {}
func (*KVResponseOp_ResponseTxn) isKVResponseOp_Response()    {}

func (m *KVResponseOp) GetResponse() isKVResponseOp_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *KVResponseOp) GetResponseQuery() *KVQueryResponse {
	if x, ok := m.GetResponse().(*KVResponseOp_ResponseQuery); ok {
		return x.ResponseQuery
	}
	return nil
}

func (m *KVResponseOp) GetResponsePut() *KVPutResponse {
	if x, ok := m.GetResponse().(*KVResponseOp_ResponsePut); ok {
		return x.ResponsePut
	}
	return nil
}

func (m *KVResponseOp) GetResponseDelete() *KVDeleteResponse {
	if x, ok := m.GetResponse().(*KVResponseOp_ResponseDelete); ok {
		return x.ResponseDelete
	}
	return nil
}

func (m *KVResponseOp) GetResponseTxn() *KVTxnResponse {
	if x, ok := m.GetResponse().(*KVResponseOp_ResponseTxn); ok {
		return x.ResponseTxn
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*KVResponseOp) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*KVResponseOp_ResponseQuery)(nil),
		(*KVResponseOp_ResponsePut)(nil),
		(*KVResponseOp_ResponseDelete)(nil),
		(*KVResponseOp_ResponseTxn)(nil),
	}
}

// Condition can be used to describe some existential
// or universal quantifier for range of keys.
type Condition struct {
	// domain describes the set of keys which form the range
	// of quantification.
	Domain []KVPredicate `protobuf:"bytes,1,rep,name=domain,proto3" json:"domain"`
	// predicate describes a condition which must hold for some
	// number of keys in the domain.
	Predicate KVPredicate `protobuf:"bytes,2,opt,name=predicate,proto3" json:"predicate"`
	// quantifier adjusts how many keys in the domain must match
	// the predicate.
	// quantifier < 0 means "for all": for all keys in the domain the predicate must hold
	// quantifier = 0 means "there does not exist"
	Quantifier Condition_Quantifier `protobuf:"varint,3,opt,name=quantifier,proto3,enum=ptarmiganpb.Condition_Quantifier" json:"quantifier,omitempty"`
}

func (m *Condition) Reset()         { *m = Condition{} }
func (m *Condition) String() string { return proto.CompactTextString(m) }
func (*Condition) ProtoMessage()    {}
func (*Condition) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{11}
}
func (m *Condition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Condition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Condition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Condition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Condition.Merge(m, src)
}
func (m *Condition) XXX_Size() int {
	return m.Size()
}
func (m *Condition) XXX_DiscardUnknown() {
	xxx_messageInfo_Condition.DiscardUnknown(m)
}

var xxx_messageInfo_Condition proto.InternalMessageInfo

type KVTxnRequest struct {
	Header PartitionRequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	// conditions is a list of predicates representing a conjunction of terms.
	// If all conditions are true, then the success requests will be processed in order,
	// and the response will contain their respective responses in order.
	// If one or more conditions are false, then the failure requests will be processed in order,
	// and the response will contain their respective responses in order.
	Conditions []Condition `protobuf:"bytes,2,rep,name=conditions,proto3" json:"conditions"`
	// success is a list of requests which will be applied when compare evaluates to true.
	Success []KVRequestOp `protobuf:"bytes,3,rep,name=success,proto3" json:"success"`
	// failure is a list of requests which will be applied when compare evaluates to false.
	Failure []KVRequestOp `protobuf:"bytes,4,rep,name=failure,proto3" json:"failure"`
}

func (m *KVTxnRequest) Reset()         { *m = KVTxnRequest{} }
func (m *KVTxnRequest) String() string { return proto.CompactTextString(m) }
func (*KVTxnRequest) ProtoMessage()    {}
func (*KVTxnRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{12}
}
func (m *KVTxnRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVTxnRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVTxnRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVTxnRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVTxnRequest.Merge(m, src)
}
func (m *KVTxnRequest) XXX_Size() int {
	return m.Size()
}
func (m *KVTxnRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_KVTxnRequest.DiscardUnknown(m)
}

var xxx_messageInfo_KVTxnRequest proto.InternalMessageInfo

type KVTxnResponse struct {
	Header ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	// succeeded is set to true if the compare evaluated to true or false otherwise.
	Succeeded bool `protobuf:"varint,2,opt,name=succeeded,proto3" json:"succeeded,omitempty"`
	// responses is a list of responses corresponding to the results from applying
	// success if succeeded is true or failure if succeeded is false.
	Responses []KVResponseOp `protobuf:"bytes,3,rep,name=responses,proto3" json:"responses"`
}

func (m *KVTxnResponse) Reset()         { *m = KVTxnResponse{} }
func (m *KVTxnResponse) String() string { return proto.CompactTextString(m) }
func (*KVTxnResponse) ProtoMessage()    {}
func (*KVTxnResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{13}
}
func (m *KVTxnResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVTxnResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVTxnResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVTxnResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVTxnResponse.Merge(m, src)
}
func (m *KVTxnResponse) XXX_Size() int {
	return m.Size()
}
func (m *KVTxnResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_KVTxnResponse.DiscardUnknown(m)
}

var xxx_messageInfo_KVTxnResponse proto.InternalMessageInfo

// CompactionRequest compacts the key-value store up to a given revision. All superseded keys
// with a revision less than the compaction revision will be removed.
type KVCompactionRequest struct {
	Header PartitionRequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	// revision is the key-value store revision for the compaction operation.
	Revision int64 `protobuf:"varint,2,opt,name=revision,proto3" json:"revision,omitempty"`
}

func (m *KVCompactionRequest) Reset()         { *m = KVCompactionRequest{} }
func (m *KVCompactionRequest) String() string { return proto.CompactTextString(m) }
func (*KVCompactionRequest) ProtoMessage()    {}
func (*KVCompactionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{14}
}
func (m *KVCompactionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVCompactionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVCompactionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVCompactionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVCompactionRequest.Merge(m, src)
}
func (m *KVCompactionRequest) XXX_Size() int {
	return m.Size()
}
func (m *KVCompactionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_KVCompactionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_KVCompactionRequest proto.InternalMessageInfo

type KVCompactionResponse struct {
	Header ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
}

func (m *KVCompactionResponse) Reset()         { *m = KVCompactionResponse{} }
func (m *KVCompactionResponse) String() string { return proto.CompactTextString(m) }
func (*KVCompactionResponse) ProtoMessage()    {}
func (*KVCompactionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{15}
}
func (m *KVCompactionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVCompactionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVCompactionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVCompactionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVCompactionResponse.Merge(m, src)
}
func (m *KVCompactionResponse) XXX_Size() int {
	return m.Size()
}
func (m *KVCompactionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_KVCompactionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_KVCompactionResponse proto.InternalMessageInfo

type KVWatchCursor struct {
	Revision int64  `protobuf:"varint,1,opt,name=revision,proto3" json:"revision,omitempty"`
	Key      []byte `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *KVWatchCursor) Reset()         { *m = KVWatchCursor{} }
func (m *KVWatchCursor) String() string { return proto.CompactTextString(m) }
func (*KVWatchCursor) ProtoMessage()    {}
func (*KVWatchCursor) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{16}
}
func (m *KVWatchCursor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVWatchCursor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVWatchCursor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVWatchCursor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVWatchCursor.Merge(m, src)
}
func (m *KVWatchCursor) XXX_Size() int {
	return m.Size()
}
func (m *KVWatchCursor) XXX_DiscardUnknown() {
	xxx_messageInfo_KVWatchCursor.DiscardUnknown(m)
}

var xxx_messageInfo_KVWatchCursor proto.InternalMessageInfo

type KeyRange struct {
	// Key must be > or >= this value
	//
	// Types that are valid to be assigned to KeyRangeMin:
	//	*KeyRange_KeyGt
	//	*KeyRange_KeyGte
	KeyRangeMin isKeyRange_KeyRangeMin `protobuf_oneof:"key_range_min"`
	// Key must be < or <= this value
	//
	// Types that are valid to be assigned to KeyRangeMax:
	//	*KeyRange_KeyLt
	//	*KeyRange_KeyLte
	KeyRangeMax isKeyRange_KeyRangeMax `protobuf_oneof:"key_range_max"`
	// Key must be prefixed with this value
	KeyStartsWith []byte `protobuf:"bytes,64,opt,name=key_starts_with,json=keyStartsWith,proto3" json:"key_starts_with,omitempty"`
	// Key must equal this value
	Key []byte `protobuf:"bytes,65,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *KeyRange) Reset()         { *m = KeyRange{} }
func (m *KeyRange) String() string { return proto.CompactTextString(m) }
func (*KeyRange) ProtoMessage()    {}
func (*KeyRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{17}
}
func (m *KeyRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyRange.Merge(m, src)
}
func (m *KeyRange) XXX_Size() int {
	return m.Size()
}
func (m *KeyRange) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyRange.DiscardUnknown(m)
}

var xxx_messageInfo_KeyRange proto.InternalMessageInfo

type isKeyRange_KeyRangeMin interface {
	isKeyRange_KeyRangeMin()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isKeyRange_KeyRangeMax interface {
	isKeyRange_KeyRangeMax()
	MarshalTo([]byte) (int, error)
	Size() int
}

type KeyRange_KeyGt struct {
	KeyGt []byte `protobuf:"bytes,1,opt,name=key_gt,json=keyGt,proto3,oneof" json:"key_gt,omitempty"`
}
type KeyRange_KeyGte struct {
	KeyGte []byte `protobuf:"bytes,2,opt,name=key_gte,json=keyGte,proto3,oneof" json:"key_gte,omitempty"`
}
type KeyRange_KeyLt struct {
	KeyLt []byte `protobuf:"bytes,3,opt,name=key_lt,json=keyLt,proto3,oneof" json:"key_lt,omitempty"`
}
type KeyRange_KeyLte struct {
	KeyLte []byte `protobuf:"bytes,4,opt,name=key_lte,json=keyLte,proto3,oneof" json:"key_lte,omitempty"`
}

func (*KeyRange_KeyGt) isKeyRange_KeyRangeMin()  {}
func (*KeyRange_KeyGte) isKeyRange_KeyRangeMin() {}
func (*KeyRange_KeyLt) isKeyRange_KeyRangeMax()  {}
func (*KeyRange_KeyLte) isKeyRange_KeyRangeMax() {}

func (m *KeyRange) GetKeyRangeMin() isKeyRange_KeyRangeMin {
	if m != nil {
		return m.KeyRangeMin
	}
	return nil
}
func (m *KeyRange) GetKeyRangeMax() isKeyRange_KeyRangeMax {
	if m != nil {
		return m.KeyRangeMax
	}
	return nil
}

func (m *KeyRange) GetKeyGt() []byte {
	if x, ok := m.GetKeyRangeMin().(*KeyRange_KeyGt); ok {
		return x.KeyGt
	}
	return nil
}

func (m *KeyRange) GetKeyGte() []byte {
	if x, ok := m.GetKeyRangeMin().(*KeyRange_KeyGte); ok {
		return x.KeyGte
	}
	return nil
}

func (m *KeyRange) GetKeyLt() []byte {
	if x, ok := m.GetKeyRangeMax().(*KeyRange_KeyLt); ok {
		return x.KeyLt
	}
	return nil
}

func (m *KeyRange) GetKeyLte() []byte {
	if x, ok := m.GetKeyRangeMax().(*KeyRange_KeyLte); ok {
		return x.KeyLte
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*KeyRange) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*KeyRange_KeyGt)(nil),
		(*KeyRange_KeyGte)(nil),
		(*KeyRange_KeyLt)(nil),
		(*KeyRange_KeyLte)(nil),
	}
}

type KVWatchRequest struct {
	Header PartitionRequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	// start is an optional cursor to watch from (exclusive). No start is "now".
	Start KVWatchCursor `protobuf:"bytes,2,opt,name=start,proto3" json:"start"`
	// Selection of keys to watch
	Keys KeyRange `protobuf:"bytes,3,opt,name=keys,proto3" json:"keys"`
	// progress_notify is set so that the ptarmigan server will periodically send a WatchResponse with
	// no events to the new watcher if there are no recent events. It is useful when clients
	// wish to recover a disconnected watcher starting from a recent known revision.
	// The ptarmigan server may decide how often it will send notifications based on current load.
	ProgressNotify bool `protobuf:"varint,4,opt,name=progress_notify,json=progressNotify,proto3" json:"progress_notify,omitempty"`
	// filter out put events.
	NoPut bool `protobuf:"varint,5,opt,name=no_put,json=noPut,proto3" json:"no_put,omitempty"`
	// filter out delete event.
	NoDelete bool `protobuf:"varint,6,opt,name=no_delete,json=noDelete,proto3" json:"no_delete,omitempty"`
	// If prev_kv is set, created watcher gets the previous KV before the event happens.
	// If the previous KV is already compacted, nothing will be returned.
	PrevKv bool `protobuf:"varint,7,opt,name=prev_kv,json=prevKv,proto3" json:"prev_kv,omitempty"`
}

func (m *KVWatchRequest) Reset()         { *m = KVWatchRequest{} }
func (m *KVWatchRequest) String() string { return proto.CompactTextString(m) }
func (*KVWatchRequest) ProtoMessage()    {}
func (*KVWatchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{18}
}
func (m *KVWatchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVWatchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVWatchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVWatchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVWatchRequest.Merge(m, src)
}
func (m *KVWatchRequest) XXX_Size() int {
	return m.Size()
}
func (m *KVWatchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_KVWatchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_KVWatchRequest proto.InternalMessageInfo

type KVWatchResponse struct {
	Header ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	// Indicates that the watch request tried watching from a
	// compacted revision. The client should treat the watcher
	// as canceled and should not try to create any watcher with
	// the same start again.
	Compacted bool `protobuf:"varint,2,opt,name=compacted,proto3" json:"compacted,omitempty"`
	// cancel_reason indicates the reason for canceling the watcher.
	CancelReason string `protobuf:"bytes,3,opt,name=cancel_reason,json=cancelReason,proto3" json:"cancel_reason,omitempty"`
	// Watchers should keep track of the latest after cursor
	// so that they can resume where they left off with a
	// subsequent watch request. If the last watch request
	// was canceled due to compaction this cursor is not valid
	// Use of an after cursor from a compacted revision will
	// result in another canceled watch request.
	After KVWatchCursor `protobuf:"bytes,4,opt,name=after,proto3" json:"after"`
	// Events contains a list of events ordered by
	// by [revision,key]. There may be events from several different
	// revisions in the events list, but events from older revisions
	// will appear first.
	Events []Event `protobuf:"bytes,11,rep,name=events,proto3" json:"events"`
}

func (m *KVWatchResponse) Reset()         { *m = KVWatchResponse{} }
func (m *KVWatchResponse) String() string { return proto.CompactTextString(m) }
func (*KVWatchResponse) ProtoMessage()    {}
func (*KVWatchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{19}
}
func (m *KVWatchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVWatchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVWatchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVWatchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVWatchResponse.Merge(m, src)
}
func (m *KVWatchResponse) XXX_Size() int {
	return m.Size()
}
func (m *KVWatchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_KVWatchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_KVWatchResponse proto.InternalMessageInfo

type LeaseGrantRequest struct {
	Header PartitionRequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	// TTL is the advisory time-to-live in seconds. Expired lease will return -1.
	TTL int64 `protobuf:"varint,2,opt,name=TTL,json=tTL,proto3" json:"TTL,omitempty"`
}

func (m *LeaseGrantRequest) Reset()         { *m = LeaseGrantRequest{} }
func (m *LeaseGrantRequest) String() string { return proto.CompactTextString(m) }
func (*LeaseGrantRequest) ProtoMessage()    {}
func (*LeaseGrantRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{20}
}
func (m *LeaseGrantRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaseGrantRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeaseGrantRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeaseGrantRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaseGrantRequest.Merge(m, src)
}
func (m *LeaseGrantRequest) XXX_Size() int {
	return m.Size()
}
func (m *LeaseGrantRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaseGrantRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LeaseGrantRequest proto.InternalMessageInfo

type LeaseGrantResponse struct {
	Header ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Lease  Lease          `protobuf:"bytes,2,opt,name=lease,proto3" json:"lease"`
}

func (m *LeaseGrantResponse) Reset()         { *m = LeaseGrantResponse{} }
func (m *LeaseGrantResponse) String() string { return proto.CompactTextString(m) }
func (*LeaseGrantResponse) ProtoMessage()    {}
func (*LeaseGrantResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{21}
}
func (m *LeaseGrantResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaseGrantResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeaseGrantResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeaseGrantResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaseGrantResponse.Merge(m, src)
}
func (m *LeaseGrantResponse) XXX_Size() int {
	return m.Size()
}
func (m *LeaseGrantResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaseGrantResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LeaseGrantResponse proto.InternalMessageInfo

type LeaseRevokeRequest struct {
	Header PartitionRequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	// ID is the lease ID to revoke. When the ID is revoked, all associated keys will be deleted.
	ID int64 `protobuf:"varint,2,opt,name=ID,json=iD,proto3" json:"ID,omitempty"`
}

func (m *LeaseRevokeRequest) Reset()         { *m = LeaseRevokeRequest{} }
func (m *LeaseRevokeRequest) String() string { return proto.CompactTextString(m) }
func (*LeaseRevokeRequest) ProtoMessage()    {}
func (*LeaseRevokeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{22}
}
func (m *LeaseRevokeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaseRevokeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeaseRevokeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeaseRevokeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaseRevokeRequest.Merge(m, src)
}
func (m *LeaseRevokeRequest) XXX_Size() int {
	return m.Size()
}
func (m *LeaseRevokeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaseRevokeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LeaseRevokeRequest proto.InternalMessageInfo

type LeaseRevokeResponse struct {
	Header ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
}

func (m *LeaseRevokeResponse) Reset()         { *m = LeaseRevokeResponse{} }
func (m *LeaseRevokeResponse) String() string { return proto.CompactTextString(m) }
func (*LeaseRevokeResponse) ProtoMessage()    {}
func (*LeaseRevokeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{23}
}
func (m *LeaseRevokeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaseRevokeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeaseRevokeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeaseRevokeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaseRevokeResponse.Merge(m, src)
}
func (m *LeaseRevokeResponse) XXX_Size() int {
	return m.Size()
}
func (m *LeaseRevokeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaseRevokeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LeaseRevokeResponse proto.InternalMessageInfo

type LeaseRenewRequest struct {
	Header PartitionRequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	// ID is the lease ID for the lease to keep alive.
	ID int64 `protobuf:"varint,2,opt,name=ID,json=iD,proto3" json:"ID,omitempty"`
}

func (m *LeaseRenewRequest) Reset()         { *m = LeaseRenewRequest{} }
func (m *LeaseRenewRequest) String() string { return proto.CompactTextString(m) }
func (*LeaseRenewRequest) ProtoMessage()    {}
func (*LeaseRenewRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{24}
}
func (m *LeaseRenewRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaseRenewRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeaseRenewRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeaseRenewRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaseRenewRequest.Merge(m, src)
}
func (m *LeaseRenewRequest) XXX_Size() int {
	return m.Size()
}
func (m *LeaseRenewRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaseRenewRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LeaseRenewRequest proto.InternalMessageInfo

type LeaseRenewResponse struct {
	Header ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Lease  Lease          `protobuf:"bytes,2,opt,name=lease,proto3" json:"lease"`
}

func (m *LeaseRenewResponse) Reset()         { *m = LeaseRenewResponse{} }
func (m *LeaseRenewResponse) String() string { return proto.CompactTextString(m) }
func (*LeaseRenewResponse) ProtoMessage()    {}
func (*LeaseRenewResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{25}
}
func (m *LeaseRenewResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaseRenewResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeaseRenewResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeaseRenewResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaseRenewResponse.Merge(m, src)
}
func (m *LeaseRenewResponse) XXX_Size() int {
	return m.Size()
}
func (m *LeaseRenewResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaseRenewResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LeaseRenewResponse proto.InternalMessageInfo

type LeaseGetRequest struct {
	Header PartitionRequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	// ID is the lease ID for the lease.
	ID int64 `protobuf:"varint,2,opt,name=ID,json=iD,proto3" json:"ID,omitempty"`
}

func (m *LeaseGetRequest) Reset()         { *m = LeaseGetRequest{} }
func (m *LeaseGetRequest) String() string { return proto.CompactTextString(m) }
func (*LeaseGetRequest) ProtoMessage()    {}
func (*LeaseGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{26}
}
func (m *LeaseGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaseGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeaseGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeaseGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaseGetRequest.Merge(m, src)
}
func (m *LeaseGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *LeaseGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaseGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LeaseGetRequest proto.InternalMessageInfo

type LeaseGetResponse struct {
	Header ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Lease  Lease          `protobuf:"bytes,2,opt,name=lease,proto3" json:"lease"`
}

func (m *LeaseGetResponse) Reset()         { *m = LeaseGetResponse{} }
func (m *LeaseGetResponse) String() string { return proto.CompactTextString(m) }
func (*LeaseGetResponse) ProtoMessage()    {}
func (*LeaseGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{27}
}
func (m *LeaseGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaseGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeaseGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeaseGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaseGetResponse.Merge(m, src)
}
func (m *LeaseGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *LeaseGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaseGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LeaseGetResponse proto.InternalMessageInfo

type LeaseQueryRequest struct {
	Header PartitionRequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
}

func (m *LeaseQueryRequest) Reset()         { *m = LeaseQueryRequest{} }
func (m *LeaseQueryRequest) String() string { return proto.CompactTextString(m) }
func (*LeaseQueryRequest) ProtoMessage()    {}
func (*LeaseQueryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{28}
}
func (m *LeaseQueryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaseQueryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeaseQueryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeaseQueryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaseQueryRequest.Merge(m, src)
}
func (m *LeaseQueryRequest) XXX_Size() int {
	return m.Size()
}
func (m *LeaseQueryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaseQueryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LeaseQueryRequest proto.InternalMessageInfo

type LeaseQueryResponse struct {
	Header ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Leases []Lease        `protobuf:"bytes,2,rep,name=leases,proto3" json:"leases"`
}

func (m *LeaseQueryResponse) Reset()         { *m = LeaseQueryResponse{} }
func (m *LeaseQueryResponse) String() string { return proto.CompactTextString(m) }
func (*LeaseQueryResponse) ProtoMessage()    {}
func (*LeaseQueryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{29}
}
func (m *LeaseQueryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaseQueryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeaseQueryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeaseQueryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaseQueryResponse.Merge(m, src)
}
func (m *LeaseQueryResponse) XXX_Size() int {
	return m.Size()
}
func (m *LeaseQueryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaseQueryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LeaseQueryResponse proto.InternalMessageInfo

type KeyValue struct {
	// key is the key in bytes. An empty key is not allowed.
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// create_revision is the revision of last creation on this key.
	CreateRevision int64 `protobuf:"varint,2,opt,name=create_revision,json=createRevision,proto3" json:"create_revision,omitempty"`
	// mod_revision is the revision of last modification on this key.
	ModRevision int64 `protobuf:"varint,3,opt,name=mod_revision,json=modRevision,proto3" json:"mod_revision,omitempty"`
	// version is the version of the key. A deletion resets
	// the version to zero and any modification of the key
	// increases its version.
	Version int64 `protobuf:"varint,4,opt,name=version,proto3" json:"version,omitempty"`
	// value is the value held by the key, in bytes.
	Value []byte `protobuf:"bytes,5,opt,name=value,proto3" json:"value,omitempty"`
	// lease is the ID of the lease that attached to key.
	// When the attached lease expires, the key will be deleted.
	// If lease is 0, then no lease is attached to the key.
	Lease int64 `protobuf:"varint,6,opt,name=lease,proto3" json:"lease,omitempty"`
}

func (m *KeyValue) Reset()         { *m = KeyValue{} }
func (m *KeyValue) String() string { return proto.CompactTextString(m) }
func (*KeyValue) ProtoMessage()    {}
func (*KeyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{30}
}
func (m *KeyValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyValue.Merge(m, src)
}
func (m *KeyValue) XXX_Size() int {
	return m.Size()
}
func (m *KeyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyValue.DiscardUnknown(m)
}

var xxx_messageInfo_KeyValue proto.InternalMessageInfo

type Event struct {
	// type is the kind of event. If type is a PUT, it indicates
	// new data has been stored to the key. If type is a DELETE,
	// it indicates the key was deleted.
	Type Event_EventType `protobuf:"varint,1,opt,name=type,proto3,enum=ptarmiganpb.Event_EventType" json:"type,omitempty"`
	// kv holds the KeyValue for the event.
	// A PUT event contains current kv pair.
	// A PUT event with kv.Version=1 indicates the creation of a key.
	// A DELETE/EXPIRE event contains the deleted key with
	// its modification revision set to the revision of deletion.
	Kv KeyValue `protobuf:"bytes,2,opt,name=kv,proto3" json:"kv"`
	// prev_kv holds the key-value pair before the event happens.
	PrevKv *KeyValue `protobuf:"bytes,3,opt,name=prev_kv,json=prevKv,proto3" json:"prev_kv,omitempty"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{31}
}
func (m *Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return m.Size()
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

type Lease struct {
	// ID is the lease ID
	ID int64 `protobuf:"varint,2,opt,name=ID,json=iD,proto3" json:"ID,omitempty"`
	// TTL is the remaining TTL in seconds for the lease; the lease will expire in under TTL+1 seconds.
	TTL int64 `protobuf:"varint,3,opt,name=TTL,json=tTL,proto3" json:"TTL,omitempty"`
	// GrantedTTL is the initial granted time in seconds upon lease creation/renewal.
	GrantedTTL int64 `protobuf:"varint,4,opt,name=grantedTTL,proto3" json:"grantedTTL,omitempty"`
}

func (m *Lease) Reset()         { *m = Lease{} }
func (m *Lease) String() string { return proto.CompactTextString(m) }
func (*Lease) ProtoMessage()    {}
func (*Lease) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{32}
}
func (m *Lease) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Lease) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Lease.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Lease) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Lease.Merge(m, src)
}
func (m *Lease) XXX_Size() int {
	return m.Size()
}
func (m *Lease) XXX_DiscardUnknown() {
	xxx_messageInfo_Lease.DiscardUnknown(m)
}

var xxx_messageInfo_Lease proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("ptarmiganpb.Field", Field_name, Field_value)
	proto.RegisterEnum("ptarmiganpb.KVPredicate_Operator", KVPredicate_Operator_name, KVPredicate_Operator_value)
	proto.RegisterEnum("ptarmiganpb.KVQueryRequest_SortOrder", KVQueryRequest_SortOrder_name, KVQueryRequest_SortOrder_value)
	proto.RegisterEnum("ptarmiganpb.Condition_Quantifier", Condition_Quantifier_name, Condition_Quantifier_value)
	proto.RegisterEnum("ptarmiganpb.Event_EventType", Event_EventType_name, Event_EventType_value)
	proto.RegisterType((*PartitionRequestHeader)(nil), "ptarmiganpb.PartitionRequestHeader")
	proto.RegisterType((*ResponseHeader)(nil), "ptarmiganpb.ResponseHeader")
	proto.RegisterType((*KVPredicate)(nil), "ptarmiganpb.KVPredicate")
	proto.RegisterType((*KVQueryRequest)(nil), "ptarmiganpb.KVQueryRequest")
	proto.RegisterType((*KVQueryResponse)(nil), "ptarmiganpb.KVQueryResponse")
	proto.RegisterType((*KVPutRequest)(nil), "ptarmiganpb.KVPutRequest")
	proto.RegisterType((*KVPutResponse)(nil), "ptarmiganpb.KVPutResponse")
	proto.RegisterType((*KVDeleteRequest)(nil), "ptarmiganpb.KVDeleteRequest")
	proto.RegisterType((*KVDeleteResponse)(nil), "ptarmiganpb.KVDeleteResponse")
	proto.RegisterType((*KVRequestOp)(nil), "ptarmiganpb.KVRequestOp")
	proto.RegisterType((*KVResponseOp)(nil), "ptarmiganpb.KVResponseOp")
	proto.RegisterType((*Condition)(nil), "ptarmiganpb.Condition")
	proto.RegisterType((*KVTxnRequest)(nil), "ptarmiganpb.KVTxnRequest")
	proto.RegisterType((*KVTxnResponse)(nil), "ptarmiganpb.KVTxnResponse")
	proto.RegisterType((*KVCompactionRequest)(nil), "ptarmiganpb.KVCompactionRequest")
	proto.RegisterType((*KVCompactionResponse)(nil), "ptarmiganpb.KVCompactionResponse")
	proto.RegisterType((*KVWatchCursor)(nil), "ptarmiganpb.KVWatchCursor")
	proto.RegisterType((*KeyRange)(nil), "ptarmiganpb.KeyRange")
	proto.RegisterType((*KVWatchRequest)(nil), "ptarmiganpb.KVWatchRequest")
	proto.RegisterType((*KVWatchResponse)(nil), "ptarmiganpb.KVWatchResponse")
	proto.RegisterType((*LeaseGrantRequest)(nil), "ptarmiganpb.LeaseGrantRequest")
	proto.RegisterType((*LeaseGrantResponse)(nil), "ptarmiganpb.LeaseGrantResponse")
	proto.RegisterType((*LeaseRevokeRequest)(nil), "ptarmiganpb.LeaseRevokeRequest")
	proto.RegisterType((*LeaseRevokeResponse)(nil), "ptarmiganpb.LeaseRevokeResponse")
	proto.RegisterType((*LeaseRenewRequest)(nil), "ptarmiganpb.LeaseRenewRequest")
	proto.RegisterType((*LeaseRenewResponse)(nil), "ptarmiganpb.LeaseRenewResponse")
	proto.RegisterType((*LeaseGetRequest)(nil), "ptarmiganpb.LeaseGetRequest")
	proto.RegisterType((*LeaseGetResponse)(nil), "ptarmiganpb.LeaseGetResponse")
	proto.RegisterType((*LeaseQueryRequest)(nil), "ptarmiganpb.LeaseQueryRequest")
	proto.RegisterType((*LeaseQueryResponse)(nil), "ptarmiganpb.LeaseQueryResponse")
	proto.RegisterType((*KeyValue)(nil), "ptarmiganpb.KeyValue")
	proto.RegisterType((*Event)(nil), "ptarmiganpb.Event")
	proto.RegisterType((*Lease)(nil), "ptarmiganpb.Lease")
}

func init() { proto.RegisterFile("rpc.proto", fileDescriptor_77a6da22d6a3feb1) }

var fileDescriptor_77a6da22d6a3feb1 = []byte{
	// 2190 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x59, 0xcd, 0x6f, 0x1b, 0xc7,
	0x15, 0xe7, 0x72, 0xb5, 0xfc, 0x78, 0xd4, 0x07, 0x3b, 0x49, 0x5c, 0x9a, 0x56, 0x64, 0x79, 0x03,
	0x37, 0x82, 0x0b, 0x4b, 0xae, 0x52, 0x18, 0xfd, 0x88, 0x5b, 0x4b, 0x14, 0x6d, 0x0a, 0x64, 0x45,
	0x79, 0x49, 0xcb, 0xed, 0x89, 0x58, 0x93, 0x23, 0x7a, 0x41, 0x72, 0x97, 0xde, 0x1d, 0xd2, 0x62,
	0x03, 0x23, 0x68, 0x7a, 0x68, 0x2f, 0x45, 0x53, 0xe4, 0x52, 0xa0, 0x40, 0x73, 0xec, 0xa1, 0x1f,
	0x87, 0x9e, 0x0a, 0xf4, 0x1f, 0xf0, 0xa9, 0x30, 0x90, 0x4b, 0x4f, 0x45, 0x63, 0xf7, 0x56, 0xa0,
	0xf7, 0x02, 0x3d, 0x14, 0xf3, 0x66, 0x76, 0xb9, 0xcb, 0x0f, 0xd7, 0xb5, 0x94, 0x20, 0x17, 0x81,
	0xf3, 0x3e, 0x66, 0x7e, 0xf3, 0x7b, 0x6f, 0xde, 0xbc, 0x59, 0x41, 0xda, 0xed, 0x37, 0x37, 0xfb,
	0xae, 0xc3, 0x1c, 0x92, 0xe9, 0x33, 0xd3, 0xed, 0x59, 0x6d, 0xd3, 0xee, 0xdf, 0xcf, 0xbf, 0xde,
	0x76, 0xda, 0x0e, 0xca, 0xb7, 0xf8, 0x2f, 0x61, 0x92, 0x5f, 0x6d, 0x3b, 0x4e, 0xbb, 0x4b, 0xb7,
	0xcc, 0xbe, 0xb5, 0x65, 0xda, 0xb6, 0xc3, 0x4c, 0x66, 0x39, 0xb6, 0x27, 0xb4, 0xfa, 0x31, 0x9c,
	0x3b, 0x34, 0x5d, 0x66, 0x71, 0x99, 0x41, 0x1f, 0x0e, 0xa8, 0xc7, 0x4a, 0xd4, 0x6c, 0x51, 0x97,
	0xbc, 0x0e, 0x9a, 0xc7, 0x1c, 0x97, 0xe6, 0x94, 0x75, 0x65, 0x23, 0x6d, 0x88, 0x01, 0x59, 0x85,
	0x74, 0xdf, 0xb7, 0xcf, 0xc5, 0x51, 0x33, 0x16, 0x90, 0x1c, 0x24, 0x5d, 0xda, 0xef, 0x5a, 0x4d,
	0x33, 0xa7, 0xa2, 0xce, 0x1f, 0xea, 0x57, 0x61, 0xd9, 0xa0, 0x5e, 0xdf, 0xb1, 0x3d, 0x2a, 0xe7,
	0xbf, 0x00, 0xe9, 0x1e, 0xed, 0xdd, 0xa7, 0x6e, 0xc3, 0x6a, 0xe1, 0x1a, 0x0b, 0x46, 0x4a, 0x08,
	0xf6, 0x5b, 0xfa, 0x4f, 0xe3, 0x90, 0x29, 0x1f, 0x1d, 0xba, 0xb4, 0x65, 0x35, 0x4d, 0x46, 0xc9,
	0x0d, 0x48, 0x39, 0x7d, 0xea, 0x9a, 0xcc, 0x71, 0xd1, 0x76, 0x79, 0xfb, 0xd2, 0x66, 0x68, 0xeb,
	0x9b, 0x21, 0xdb, 0xcd, 0xaa, 0x34, 0x34, 0x02, 0x17, 0xb2, 0x01, 0xda, 0xb1, 0x45, 0xbb, 0x2d,
	0x44, 0xbc, 0xbc, 0x4d, 0x22, 0xbe, 0xb7, 0xb8, 0xc6, 0x10, 0x06, 0xe4, 0x1c, 0x68, 0x96, 0xcd,
	0xae, 0x7f, 0x1d, 0xf1, 0xab, 0xa5, 0x98, 0x21, 0x86, 0x5c, 0x7e, 0x7f, 0xc4, 0xa8, 0x97, 0x5b,
	0x58, 0x57, 0x36, 0x16, 0xb9, 0x1c, 0x87, 0xfa, 0x3d, 0x48, 0xf9, 0xeb, 0x91, 0x34, 0x68, 0xc5,
	0x3b, 0x77, 0x77, 0x2a, 0xd9, 0x18, 0x59, 0x82, 0xf4, 0x41, 0xb5, 0xde, 0x10, 0x43, 0x85, 0x24,
	0x20, 0x7e, 0xbb, 0x9e, 0x8d, 0x93, 0x24, 0xa8, 0xb7, 0xeb, 0xc5, 0xac, 0xca, 0x05, 0x95, 0x7a,
	0x76, 0x81, 0x0b, 0x2a, 0xf5, 0x62, 0x56, 0x23, 0x2b, 0x90, 0xa9, 0xd5, 0x77, 0x8c, 0x7a, 0xad,
	0x71, 0x6f, 0xbf, 0x5e, 0xca, 0x26, 0x76, 0x93, 0xa0, 0x0d, 0xcd, 0xee, 0x80, 0xea, 0xff, 0x52,
	0x61, 0xb9, 0x7c, 0x74, 0x67, 0x40, 0xdd, 0x91, 0x0c, 0x10, 0xd9, 0x81, 0xc4, 0x03, 0x24, 0x11,
	0xb9, 0xc8, 0x6c, 0xbf, 0x15, 0xd9, 0xcf, 0xec, 0x78, 0xee, 0x2e, 0x3c, 0xf9, 0xdb, 0xc5, 0x98,
	0x21, 0x1d, 0xc9, 0xbb, 0x90, 0xf6, 0x68, 0x97, 0x36, 0x65, 0x1c, 0xd5, 0x8d, 0xcc, 0x76, 0x6e,
	0x1e, 0xa3, 0xd2, 0x75, 0xec, 0xc0, 0x73, 0xc3, 0x3c, 0x66, 0xd4, 0x95, 0x51, 0x16, 0x03, 0x2e,
	0xed, 0x5a, 0x3d, 0x8b, 0x21, 0x47, 0xaa, 0x21, 0x06, 0x24, 0x0f, 0x29, 0x97, 0x0e, 0x2d, 0x8f,
	0x2f, 0xa4, 0xa1, 0x22, 0x18, 0x93, 0x3d, 0x00, 0xcf, 0x71, 0x59, 0xc3, 0x71, 0xf9, 0x66, 0x12,
	0x18, 0x9c, 0xcb, 0x13, 0x30, 0xc2, 0x3b, 0xdf, 0xac, 0x39, 0x2e, 0xab, 0x72, 0x63, 0x23, 0xed,
	0xf9, 0x3f, 0xc9, 0x3b, 0x90, 0xc1, 0x59, 0x98, 0xe9, 0xb6, 0x29, 0xcb, 0x25, 0xe7, 0xc6, 0x18,
	0x17, 0xab, 0xa3, 0x15, 0xd1, 0x61, 0xd1, 0xa3, 0xae, 0x65, 0x76, 0xad, 0x1f, 0x9a, 0xf7, 0xbb,
	0x34, 0x97, 0x5a, 0x57, 0x36, 0x52, 0x46, 0x44, 0x46, 0x2e, 0xc3, 0x32, 0x3d, 0x69, 0x76, 0x07,
	0x2d, 0xda, 0xc0, 0x58, 0x78, 0xb9, 0x34, 0x5a, 0x2d, 0x49, 0xe9, 0x11, 0x0a, 0xc9, 0x5b, 0xb0,
	0x64, 0xd9, 0xc2, 0xac, 0xe9, 0x0c, 0x6c, 0x96, 0x03, 0x31, 0x97, 0x14, 0x16, 0xb8, 0x4c, 0xdf,
	0x80, 0x74, 0x00, 0x9e, 0xa4, 0x60, 0xe1, 0xa0, 0x7a, 0x50, 0xcc, 0xc6, 0x78, 0x02, 0xec, 0xd4,
	0x0a, 0x59, 0x85, 0x8b, 0xf6, 0x8a, 0xb5, 0x42, 0x36, 0xae, 0xff, 0x59, 0x81, 0x95, 0x60, 0xdb,
	0xe2, 0xc8, 0x90, 0x6f, 0x4e, 0x44, 0xfc, 0x42, 0x64, 0x77, 0xd1, 0x93, 0x35, 0x11, 0xe9, 0xab,
	0xa0, 0x76, 0x86, 0x9e, 0x8c, 0xf1, 0x1b, 0x51, 0x72, 0xe9, 0x08, 0xb7, 0x20, 0x3d, 0xb8, 0x1d,
	0x21, 0xb0, 0xd0, 0xe3, 0xa7, 0x5e, 0xc5, 0x3d, 0xe0, 0xef, 0x71, 0xb8, 0x17, 0x26, 0xc2, 0x2d,
	0xb6, 0x2b, 0xa2, 0x2a, 0x06, 0xfa, 0xef, 0xe2, 0xb0, 0x58, 0x3e, 0x3a, 0x1c, 0xb0, 0x2f, 0x4c,
	0xb2, 0x66, 0x41, 0xed, 0xd0, 0x11, 0x6e, 0x68, 0xd1, 0xe0, 0x3f, 0x39, 0x72, 0x8c, 0xa7, 0x38,
	0xcc, 0x86, 0x18, 0x60, 0xfa, 0x52, 0xd3, 0xa3, 0xfe, 0x7e, 0x70, 0x40, 0xbe, 0x0c, 0xc9, 0xbe,
	0x4b, 0x87, 0x8d, 0xce, 0x10, 0xf3, 0x33, 0x65, 0x24, 0xf8, 0xb0, 0x3c, 0x24, 0x97, 0x60, 0xd1,
	0x6a, 0xdb, 0x8e, 0x2b, 0x73, 0x03, 0xd3, 0x2e, 0x65, 0x64, 0x84, 0x0c, 0x69, 0x0d, 0x99, 0x88,
	0x89, 0x53, 0x61, 0x93, 0x0a, 0x17, 0xe9, 0x1f, 0x28, 0xb0, 0x24, 0xe9, 0x3a, 0x7d, 0xa8, 0xaf,
	0x43, 0x4a, 0x62, 0x7d, 0xa9, 0x78, 0x27, 0xc5, 0x4e, 0x3c, 0xfd, 0xb7, 0x98, 0x71, 0x7b, 0xb4,
	0x4b, 0x19, 0xfd, 0xc2, 0x84, 0x2d, 0x44, 0xbc, 0x1a, 0x26, 0x5e, 0xff, 0x58, 0x81, 0xec, 0x18,
	0xed, 0xe9, 0x59, 0xcb, 0x41, 0xb2, 0x85, 0x93, 0x89, 0xeb, 0x41, 0x35, 0xfc, 0x61, 0x84, 0x4f,
	0xf5, 0xff, 0xe0, 0xf3, 0x63, 0xbc, 0xbd, 0x24, 0x35, 0xd5, 0x3e, 0xd9, 0x85, 0x25, 0x57, 0x0c,
	0x1a, 0x0f, 0xf9, 0xb1, 0x9e, 0x89, 0x31, 0x5a, 0xe9, 0x4a, 0x31, 0x63, 0x51, 0xfa, 0xa0, 0x98,
	0xbc, 0x0b, 0x19, 0x7f, 0x8e, 0xfe, 0x80, 0x21, 0xd2, 0xcc, 0xf6, 0xf9, 0x49, 0x3a, 0x83, 0x63,
	0x57, 0x8a, 0x19, 0x20, 0xed, 0x0f, 0x07, 0x8c, 0x14, 0x61, 0xd9, 0xf7, 0x16, 0x9b, 0x43, 0x4e,
	0x33, 0xdb, 0xab, 0x13, 0x13, 0x44, 0x72, 0xa0, 0x14, 0x33, 0x7c, 0xdc, 0x42, 0x1e, 0x06, 0xc1,
	0x4e, 0x6c, 0x3c, 0x3e, 0xd3, 0x20, 0xea, 0x27, 0xf6, 0x34, 0x88, 0xfa, 0x89, 0xbd, 0x9b, 0xe6,
	0xdd, 0x01, 0x8e, 0xf4, 0xdf, 0x63, 0x95, 0xf0, 0xc3, 0x52, 0xed, 0x0b, 0x80, 0x62, 0x14, 0xe1,
	0x68, 0x75, 0x36, 0x47, 0x32, 0x9c, 0x08, 0x50, 0xfc, 0x16, 0x2c, 0x7d, 0x17, 0x16, 0x83, 0x69,
	0xc6, 0x34, 0xe5, 0x67, 0xd1, 0x14, 0x4c, 0x91, 0xf1, 0x3d, 0x38, 0x51, 0x25, 0x58, 0x09, 0x26,
	0x88, 0x30, 0xf5, 0xe6, 0x1c, 0xa6, 0x82, 0x69, 0x02, 0xfc, 0x92, 0xab, 0x30, 0x94, 0x31, 0x59,
	0xf9, 0x59, 0x64, 0x4d, 0x43, 0xe1, 0x74, 0x01, 0xbf, 0x38, 0xc5, 0x50, 0xff, 0xa7, 0x02, 0xe9,
	0x82, 0x63, 0xb7, 0x44, 0x9b, 0x75, 0x1d, 0x12, 0x2d, 0xa7, 0x67, 0x5a, 0x76, 0x4e, 0x79, 0xa9,
	0x53, 0x25, 0xad, 0xf9, 0x81, 0xec, 0xfb, 0x2a, 0x49, 0xcd, 0xff, 0x3c, 0x90, 0x81, 0x03, 0xd9,
	0x01, 0x78, 0x38, 0x30, 0x6d, 0x66, 0x1d, 0x5b, 0xf2, 0xe6, 0x9f, 0xec, 0xc2, 0x02, 0x84, 0x9b,
	0x77, 0x02, 0x43, 0x23, 0xe4, 0xa4, 0x5f, 0x06, 0x18, 0x6b, 0x48, 0x06, 0x92, 0xb7, 0xaa, 0x46,
	0x63, 0xa7, 0xc2, 0x3b, 0x26, 0x80, 0x44, 0xf1, 0xfb, 0xfb, 0xb5, 0x7a, 0x2d, 0xab, 0xe8, 0x3f,
	0xc6, 0xec, 0x18, 0xe7, 0xd1, 0xd9, 0x14, 0x23, 0x68, 0xfa, 0xf0, 0xfc, 0xea, 0x78, 0x6e, 0x36,
	0x7a, 0xe9, 0x19, 0xb2, 0x27, 0xdf, 0x80, 0xa4, 0x37, 0x68, 0x36, 0xa9, 0xe7, 0x17, 0x82, 0x49,
	0xde, 0x82, 0xc3, 0xee, 0xd7, 0x02, 0x69, 0xce, 0x3d, 0x8f, 0x4d, 0xab, 0x3b, 0x70, 0xf9, 0x6d,
	0xf3, 0x52, 0x9e, 0xd2, 0x5c, 0xff, 0x0d, 0x5e, 0x0d, 0xa1, 0x04, 0x39, 0x4d, 0x91, 0x5b, 0x85,
	0x34, 0x22, 0xa2, 0x2d, 0x59, 0xe6, 0x52, 0xc6, 0x58, 0x40, 0x6e, 0x40, 0xda, 0x4f, 0x35, 0x7f,
	0x83, 0xe7, 0xa7, 0x60, 0xfa, 0x67, 0xd5, 0xcf, 0x8c, 0xc0, 0x43, 0x67, 0xf0, 0x5a, 0xf9, 0xa8,
	0xe0, 0xf4, 0xfa, 0x66, 0x33, 0x14, 0x86, 0xb3, 0x88, 0x5a, 0xb8, 0x79, 0x8c, 0x47, 0x9b, 0x47,
	0xfd, 0x0e, 0xbc, 0x1e, 0x5d, 0xf5, 0xd4, 0x2c, 0xe9, 0x37, 0x38, 0xe3, 0xf7, 0x4c, 0xd6, 0x7c,
	0x50, 0x18, 0xb8, 0x9e, 0x13, 0x5d, 0x5f, 0x99, 0x68, 0x5e, 0x65, 0x5f, 0x11, 0x0f, 0xfa, 0x0a,
	0xfd, 0x2f, 0x0a, 0xa4, 0xca, 0x74, 0x64, 0x98, 0x76, 0x9b, 0x37, 0x0e, 0x89, 0x0e, 0x1d, 0x35,
	0xda, 0x0c, 0x1d, 0xf1, 0xc9, 0xd0, 0xa1, 0xa3, 0xdb, 0x8c, 0x9c, 0x87, 0xa4, 0x50, 0x88, 0x33,
	0xc8, 0x35, 0x09, 0xd4, 0x04, 0x3e, 0x5d, 0x26, 0xba, 0x95, 0x92, 0x82, 0x3e, 0x95, 0xc0, 0xa7,
	0xcb, 0x64, 0xcf, 0x52, 0x52, 0xd0, 0xa7, 0xc2, 0x28, 0xf9, 0x0a, 0xac, 0x70, 0x95, 0xc7, 0x4c,
	0x97, 0x79, 0x8d, 0x47, 0x16, 0x7b, 0x90, 0xbb, 0x89, 0x90, 0x96, 0x3a, 0x74, 0x54, 0x43, 0xe9,
	0x3d, 0x8b, 0x3d, 0xf0, 0xe1, 0xee, 0x04, 0x70, 0x77, 0x57, 0x80, 0x9b, 0x34, 0x5c, 0x0e, 0xb7,
	0xd1, 0xb3, 0xec, 0x09, 0x81, 0x79, 0xa2, 0xff, 0x31, 0xce, 0xdf, 0x1e, 0x48, 0xc8, 0x19, 0x06,
	0xf5, 0x3a, 0x7f, 0x59, 0x9a, 0xee, 0xbc, 0xea, 0x1c, 0xe2, 0x5f, 0x3a, 0x0a, 0x73, 0xb2, 0x05,
	0x0b, 0x1d, 0x3a, 0xf2, 0x64, 0x41, 0x9e, 0xba, 0x8a, 0x91, 0x76, 0xe9, 0x81, 0x86, 0xe4, 0x6d,
	0x58, 0xe9, 0xbb, 0x4e, 0xdb, 0xa5, 0x9e, 0xd7, 0xb0, 0x1d, 0x66, 0x1d, 0x8f, 0x90, 0xbd, 0x94,
	0xb1, 0xec, 0x8b, 0x0f, 0x50, 0x4a, 0xde, 0x80, 0x84, 0xed, 0xe0, 0x85, 0xa1, 0xa1, 0x5e, 0xb3,
	0x1d, 0x7e, 0x19, 0x5c, 0x80, 0xb4, 0xed, 0xf8, 0xd7, 0x80, 0xe8, 0xfe, 0x52, 0xb6, 0x23, 0xeb,
	0x7b, 0xa8, 0x3f, 0x49, 0x46, 0xfa, 0x93, 0x7f, 0x63, 0x37, 0x25, 0x49, 0x3b, 0x93, 0x93, 0xdb,
	0x14, 0x49, 0x3e, 0x3e, 0xb9, 0x81, 0x80, 0xbf, 0x3d, 0x9a, 0xa6, 0xdd, 0xa4, 0xdd, 0x86, 0x4b,
	0x4d, 0xcf, 0xb1, 0xe5, 0x8b, 0x6c, 0x51, 0x08, 0x0d, 0x94, 0x71, 0xc2, 0xc7, 0xfd, 0xfb, 0x4b,
	0x11, 0x2e, 0x3a, 0xfc, 0x6b, 0x90, 0xa0, 0x43, 0x6a, 0x33, 0x2f, 0x97, 0xc1, 0x9a, 0x10, 0x7d,
	0x53, 0x15, 0xb9, 0xca, 0x07, 0x2b, 0xec, 0xf4, 0x07, 0xf0, 0x25, 0xec, 0x6b, 0x6f, 0xbb, 0xa6,
	0x7d, 0x96, 0x2f, 0x80, 0x2c, 0xa8, 0xf5, 0x7a, 0x45, 0x96, 0x00, 0x95, 0xd5, 0x2b, 0xfa, 0xfb,
	0x40, 0xc2, 0x2b, 0x9d, 0x9e, 0xe7, 0x4d, 0xbf, 0xfd, 0x17, 0x59, 0x19, 0xdd, 0x2b, 0x2e, 0xe5,
	0x93, 0x83, 0x66, 0x7a, 0x5b, 0x02, 0x30, 0xe8, 0xd0, 0xe9, 0x9c, 0x65, 0xdb, 0xbc, 0x0c, 0xf1,
	0xfd, 0x3d, 0xb9, 0xd5, 0xb8, 0xb5, 0xa7, 0x1f, 0xc2, 0x6b, 0x91, 0x85, 0x4e, 0x5f, 0xe6, 0x8e,
	0x65, 0x94, 0x0c, 0x6a, 0xd3, 0x47, 0x9f, 0x21, 0xf2, 0xf7, 0x03, 0x8a, 0x70, 0x9d, 0xcf, 0x3f,
	0x46, 0x2d, 0x58, 0x11, 0x49, 0x42, 0xd9, 0x67, 0xb8, 0xcd, 0xc7, 0x90, 0x1d, 0xaf, 0xf2, 0xf9,
	0x6f, 0xf2, 0x48, 0x46, 0xf3, 0x8c, 0x3f, 0x11, 0xe9, 0x3f, 0x52, 0x64, 0xf8, 0xce, 0xec, 0x53,
	0xc4, 0x35, 0x48, 0x20, 0x64, 0xbf, 0xff, 0x9a, 0xbf, 0x35, 0x69, 0xa7, 0xff, 0x41, 0xdc, 0xa8,
	0xe2, 0x39, 0x2d, 0x6f, 0x30, 0x65, 0xfc, 0x90, 0x7f, 0x1b, 0x56, 0x9a, 0x2e, 0x35, 0x19, 0x6d,
	0x4c, 0x74, 0x09, 0xcb, 0x42, 0x6c, 0xf8, 0x77, 0xf5, 0x25, 0x58, 0xec, 0x39, 0xad, 0xb1, 0x15,
	0x7e, 0xdd, 0x33, 0x32, 0x3d, 0xa7, 0x15, 0x98, 0xe4, 0x20, 0x39, 0xa4, 0x2e, 0x6a, 0xc5, 0xf7,
	0x2b, 0x7f, 0x38, 0xfe, 0x5c, 0xa0, 0xcd, 0xfc, 0x5c, 0x90, 0x08, 0x7d, 0x2e, 0xd0, 0xff, 0xa4,
	0x80, 0x86, 0x85, 0x91, 0x5c, 0x83, 0x05, 0x36, 0xea, 0x53, 0xf9, 0xb9, 0x72, 0x75, 0xba, 0x74,
	0x8a, 0xbf, 0xf5, 0x51, 0x9f, 0x1a, 0x68, 0x49, 0xbe, 0x0a, 0xf1, 0xce, 0x50, 0x46, 0xfd, 0x85,
	0x0f, 0xcd, 0x78, 0x67, 0x48, 0x36, 0xa3, 0xcf, 0xe3, 0x79, 0x1e, 0xc1, 0xad, 0xb4, 0x0e, 0xe9,
	0x60, 0x3d, 0x92, 0x04, 0xf5, 0xf0, 0x6e, 0x5d, 0x74, 0xdd, 0x7b, 0xc5, 0x4a, 0xb1, 0x5e, 0xcc,
	0x2a, 0xfa, 0x3e, 0x68, 0x18, 0x82, 0xc9, 0xfc, 0xf6, 0x8b, 0xaf, 0x1a, 0x14, 0x5f, 0xb2, 0x06,
	0xd0, 0xe6, 0x75, 0x97, 0xb6, 0xb8, 0x42, 0xd0, 0x15, 0x92, 0x5c, 0x29, 0x81, 0x86, 0x5f, 0xdc,
	0x78, 0x8b, 0x7f, 0x54, 0x34, 0x6a, 0xfb, 0xd5, 0x03, 0xb1, 0x58, 0xc1, 0x28, 0xee, 0xf0, 0xc5,
	0x38, 0x82, 0xef, 0x55, 0xf7, 0xb2, 0x71, 0x92, 0x06, 0xed, 0x68, 0xa7, 0x72, 0xb7, 0x98, 0x55,
	0xf9, 0xcf, 0x4a, 0x71, 0xa7, 0x56, 0x14, 0xdf, 0x45, 0xcb, 0xc5, 0x1f, 0x64, 0xb5, 0xed, 0x4f,
	0x16, 0x20, 0x5e, 0x3e, 0x22, 0x3f, 0x51, 0x40, 0x13, 0x2f, 0xbc, 0x17, 0x3d, 0x9a, 0xf3, 0x2f,
	0x7c, 0x2d, 0xea, 0x85, 0x0f, 0x3e, 0xf9, 0xc7, 0x47, 0xf1, 0x1b, 0xe4, 0xdb, 0x5b, 0xc3, 0xaf,
	0x6d, 0xe1, 0xe7, 0x6c, 0x6f, 0xeb, 0x3d, 0x91, 0x9a, 0x9b, 0x38, 0x7c, 0xbc, 0x15, 0x7c, 0xca,
	0x1e, 0x6b, 0x02, 0xd1, 0xe3, 0xad, 0xce, 0xd0, 0x23, 0x3f, 0x53, 0x40, 0xad, 0x9f, 0xd8, 0x64,
	0xfe, 0xab, 0x37, 0xff, 0x82, 0x37, 0x9e, 0x5e, 0x45, 0x0c, 0xfb, 0xfa, 0xde, 0xab, 0x62, 0x60,
	0xae, 0x69, 0x7b, 0xa2, 0xe3, 0xf5, 0xbe, 0xa5, 0x5c, 0x21, 0xbf, 0x56, 0x20, 0x29, 0x9b, 0x60,
	0xb2, 0x3e, 0xb1, 0xf0, 0x54, 0x4b, 0x9e, 0xbf, 0xf4, 0x02, 0x0b, 0x89, 0xf0, 0x00, 0x11, 0x96,
	0xf4, 0xc2, 0xab, 0x22, 0x6c, 0x06, 0x73, 0x22, 0xc0, 0x5f, 0x28, 0xa0, 0x61, 0x87, 0x31, 0x15,
	0xba, 0x70, 0x5f, 0x39, 0x15, 0xba, 0x48, 0xff, 0xa4, 0x97, 0x11, 0x54, 0x51, 0xbf, 0xf9, 0xaa,
	0xa0, 0x1e, 0xf1, 0xe9, 0xa8, 0xcb, 0x11, 0x5d, 0x53, 0xb6, 0xff, 0xa3, 0x41, 0x02, 0x73, 0xdd,
	0x23, 0x1f, 0x29, 0xa0, 0x61, 0x0f, 0x41, 0xd6, 0xa6, 0xab, 0x51, 0xb8, 0x8d, 0xc9, 0x5f, 0x9c,
	0xab, 0x97, 0x20, 0xf7, 0x11, 0x64, 0x41, 0xff, 0xce, 0xab, 0x82, 0x14, 0x45, 0x8f, 0x93, 0xf6,
	0x61, 0x90, 0xef, 0x33, 0x50, 0x45, 0x52, 0xfe, 0xe2, 0x5c, 0xbd, 0x44, 0x75, 0x0b, 0x51, 0xdd,
	0x24, 0xa7, 0x44, 0x45, 0x7e, 0xae, 0x80, 0x7a, 0x9b, 0x32, 0xb2, 0x3a, 0x83, 0x86, 0xe0, 0x7a,
	0xcd, 0xbf, 0x39, 0x47, 0x1b, 0x8d, 0x23, 0x29, 0x9c, 0x0e, 0xcc, 0xd6, 0x7b, 0xfb, 0x7b, 0x8f,
	0xc9, 0x2f, 0x15, 0x48, 0x88, 0xa6, 0x88, 0xcc, 0x60, 0x21, 0xd2, 0x97, 0xe5, 0xd7, 0xe7, 0x1b,
	0x44, 0xa1, 0x5d, 0x39, 0x13, 0x68, 0xbf, 0x52, 0x40, 0xc3, 0xae, 0x67, 0x56, 0xfc, 0xc2, 0x6d,
	0x57, 0xfe, 0xe2, 0x5c, 0xbd, 0xc4, 0x75, 0x07, 0x71, 0x95, 0xf5, 0x5b, 0xa7, 0xc2, 0x75, 0xd5,
	0xe5, 0x93, 0x9a, 0x5d, 0x9e, 0x5d, 0xbb, 0xeb, 0x4f, 0x3e, 0x5d, 0x8b, 0x3d, 0xfd, 0x74, 0x2d,
	0xf6, 0xe4, 0xd9, 0x9a, 0xf2, 0xf4, 0xd9, 0x9a, 0xf2, 0xf7, 0x67, 0x6b, 0xca, 0x87, 0xcf, 0xd7,
	0x62, 0x4f, 0x9f, 0xaf, 0xc5, 0xfe, 0xfa, 0x7c, 0x2d, 0x76, 0x3f, 0x81, 0xff, 0x1d, 0x7c, 0xe7,
	0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x96, 0x5d, 0x26, 0xcb, 0x6b, 0x1c, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// KVClient is the client API for KV service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type KVClient interface {
	// Query retrieves kvs from a partition
	Query(ctx context.Context, in *KVQueryRequest, opts ...grpc.CallOption) (*KVQueryResponse, error)
	// Txn processes multiple requests in a single transaction.
	// A txn request increments the revision of the key-value store
	// and generates events with the same revision for every completed request.
	Txn(ctx context.Context, in *KVTxnRequest, opts ...grpc.CallOption) (*KVTxnResponse, error)
	// Compact compacts the event history in the key-value store. The key-value
	// store should be periodically compacted or the event history will continue to grow
	// indefinitely.
	Compact(ctx context.Context, in *KVCompactionRequest, opts ...grpc.CallOption) (*KVCompactionResponse, error)
	// Watch creates a watcher to watch for events happening or that have happened.
	// The entire event history can be watched starting from the last compaction revision.
	Watch(ctx context.Context, in *KVWatchRequest, opts ...grpc.CallOption) (KV_WatchClient, error)
}

type kVClient struct {
	cc *grpc.ClientConn
}

func NewKVClient(cc *grpc.ClientConn) KVClient {
	return &kVClient{cc}
}

func (c *kVClient) Query(ctx context.Context, in *KVQueryRequest, opts ...grpc.CallOption) (*KVQueryResponse, error) {
	out := new(KVQueryResponse)
	err := c.cc.Invoke(ctx, "/ptarmiganpb.KV/Query", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVClient) Txn(ctx context.Context, in *KVTxnRequest, opts ...grpc.CallOption) (*KVTxnResponse, error) {
	out := new(KVTxnResponse)
	err := c.cc.Invoke(ctx, "/ptarmiganpb.KV/Txn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVClient) Compact(ctx context.Context, in *KVCompactionRequest, opts ...grpc.CallOption) (*KVCompactionResponse, error) {
	out := new(KVCompactionResponse)
	err := c.cc.Invoke(ctx, "/ptarmiganpb.KV/Compact", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVClient) Watch(ctx context.Context, in *KVWatchRequest, opts ...grpc.CallOption) (KV_WatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &_KV_serviceDesc.Streams[0], "/ptarmiganpb.KV/Watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &kVWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type KV_WatchClient interface {
	Recv() (*KVWatchResponse, error)
	grpc.ClientStream
}

type kVWatchClient struct {
	grpc.ClientStream
}

func (x *kVWatchClient) Recv() (*KVWatchResponse, error) {
	m := new(KVWatchResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// KVServer is the server API for KV service.
type KVServer interface {
	// Query retrieves kvs from a partition
	Query(context.Context, *KVQueryRequest) (*KVQueryResponse, error)
	// Txn processes multiple requests in a single transaction.
	// A txn request increments the revision of the key-value store
	// and generates events with the same revision for every completed request.
	Txn(context.Context, *KVTxnRequest) (*KVTxnResponse, error)
	// Compact compacts the event history in the key-value store. The key-value
	// store should be periodically compacted or the event history will continue to grow
	// indefinitely.
	Compact(context.Context, *KVCompactionRequest) (*KVCompactionResponse, error)
	// Watch creates a watcher to watch for events happening or that have happened.
	// The entire event history can be watched starting from the last compaction revision.
	Watch(*KVWatchRequest, KV_WatchServer) error
}

// UnimplementedKVServer can be embedded to have forward compatible implementations.
type UnimplementedKVServer struct {
}

func (*UnimplementedKVServer) Query(ctx context.Context, req *KVQueryRequest) (*KVQueryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Query not implemented")
}
func (*UnimplementedKVServer) Txn(ctx context.Context, req *KVTxnRequest) (*KVTxnResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Txn not implemented")
}
func (*UnimplementedKVServer) Compact(ctx context.Context, req *KVCompactionRequest) (*KVCompactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Compact not implemented")
}
func (*UnimplementedKVServer) Watch(req *KVWatchRequest, srv KV_WatchServer) error {
	return status.Errorf(codes.Unimplemented, "method Watch not implemented")
}

func RegisterKVServer(s *grpc.Server, srv KVServer) {
	s.RegisterService(&_KV_serviceDesc, srv)
}

func _KV_Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KVQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVServer).Query(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ptarmiganpb.KV/Query",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVServer).Query(ctx, req.(*KVQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KV_Txn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KVTxnRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVServer).Txn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ptarmiganpb.KV/Txn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVServer).Txn(ctx, req.(*KVTxnRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KV_Compact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KVCompactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVServer).Compact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ptarmiganpb.KV/Compact",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVServer).Compact(ctx, req.(*KVCompactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KV_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(KVWatchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KVServer).Watch(m, &kVWatchServer{stream})
}

type KV_WatchServer interface {
	Send(*KVWatchResponse) error
	grpc.ServerStream
}

type kVWatchServer struct {
	grpc.ServerStream
}

func (x *kVWatchServer) Send(m *KVWatchResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _KV_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ptarmiganpb.KV",
	HandlerType: (*KVServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Query",
			Handler:    _KV_Query_Handler,
		},
		{
			MethodName: "Txn",
			Handler:    _KV_Txn_Handler,
		},
		{
			MethodName: "Compact",
			Handler:    _KV_Compact_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _KV_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "rpc.proto",
}

// LeasesClient is the client API for Leases service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type LeasesClient interface {
	// Grant creates a lease which expires if the server does not receive a renewal
	// within a given time to live period. All keys attached to the lease will be expired and
	// deleted if the lease expires. Each expired key generates a delete event in the event history.
	Grant(ctx context.Context, in *LeaseGrantRequest, opts ...grpc.CallOption) (*LeaseGrantResponse, error)
	Query(ctx context.Context, in *LeaseQueryRequest, opts ...grpc.CallOption) (*LeaseQueryResponse, error)
	// Get retrieves information on a lease.
	Get(ctx context.Context, in *LeaseGetRequest, opts ...grpc.CallOption) (*LeaseGetResponse, error)
	// Revoke revokes a lease. All keys attached to the lease will expire and be deleted.
	Revoke(ctx context.Context, in *LeaseRevokeRequest, opts ...grpc.CallOption) (*LeaseRevokeResponse, error)
	// Renew renews the lease so that it does not expire
	Renew(ctx context.Context, in *LeaseRenewRequest, opts ...grpc.CallOption) (*LeaseRenewResponse, error)
}

type leasesClient struct {
	cc *grpc.ClientConn
}

func NewLeasesClient(cc *grpc.ClientConn) LeasesClient {
	return &leasesClient{cc}
}

func (c *leasesClient) Grant(ctx context.Context, in *LeaseGrantRequest, opts ...grpc.CallOption) (*LeaseGrantResponse, error) {
	out := new(LeaseGrantResponse)
	err := c.cc.Invoke(ctx, "/ptarmiganpb.Leases/Grant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leasesClient) Query(ctx context.Context, in *LeaseQueryRequest, opts ...grpc.CallOption) (*LeaseQueryResponse, error) {
	out := new(LeaseQueryResponse)
	err := c.cc.Invoke(ctx, "/ptarmiganpb.Leases/Query", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leasesClient) Get(ctx context.Context, in *LeaseGetRequest, opts ...grpc.CallOption) (*LeaseGetResponse, error) {
	out := new(LeaseGetResponse)
	err := c.cc.Invoke(ctx, "/ptarmiganpb.Leases/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leasesClient) Revoke(ctx context.Context, in *LeaseRevokeRequest, opts ...grpc.CallOption) (*LeaseRevokeResponse, error) {
	out := new(LeaseRevokeResponse)
	err := c.cc.Invoke(ctx, "/ptarmiganpb.Leases/Revoke", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leasesClient) Renew(ctx context.Context, in *LeaseRenewRequest, opts ...grpc.CallOption) (*LeaseRenewResponse, error) {
	out := new(LeaseRenewResponse)
	err := c.cc.Invoke(ctx, "/ptarmiganpb.Leases/Renew", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LeasesServer is the server API for Leases service.
type LeasesServer interface {
	// Grant creates a lease which expires if the server does not receive a renewal
	// within a given time to live period. All keys attached to the lease will be expired and
	// deleted if the lease expires. Each expired key generates a delete event in the event history.
	Grant(context.Context, *LeaseGrantRequest) (*LeaseGrantResponse, error)
	Query(context.Context, *LeaseQueryRequest) (*LeaseQueryResponse, error)
	// Get retrieves information on a lease.
	Get(context.Context, *LeaseGetRequest) (*LeaseGetResponse, error)
	// Revoke revokes a lease. All keys attached to the lease will expire and be deleted.
	Revoke(context.Context, *LeaseRevokeRequest) (*LeaseRevokeResponse, error)
	// Renew renews the lease so that it does not expire
	Renew(context.Context, *LeaseRenewRequest) (*LeaseRenewResponse, error)
}

// UnimplementedLeasesServer can be embedded to have forward compatible implementations.
type UnimplementedLeasesServer struct {
}

func (*UnimplementedLeasesServer) Grant(ctx context.Context, req *LeaseGrantRequest) (*LeaseGrantResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Grant not implemented")
}
func (*UnimplementedLeasesServer) Query(ctx context.Context, req *LeaseQueryRequest) (*LeaseQueryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Query not implemented")
}
func (*UnimplementedLeasesServer) Get(ctx context.Context, req *LeaseGetRequest) (*LeaseGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (*UnimplementedLeasesServer) Revoke(ctx context.Context, req *LeaseRevokeRequest) (*LeaseRevokeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Revoke not implemented")
}
func (*UnimplementedLeasesServer) Renew(ctx context.Context, req *LeaseRenewRequest) (*LeaseRenewResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Renew not implemented")
}

func RegisterLeasesServer(s *grpc.Server, srv LeasesServer) {
	s.RegisterService(&_Leases_serviceDesc, srv)
}

func _Leases_Grant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaseGrantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeasesServer).Grant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ptarmiganpb.Leases/Grant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeasesServer).Grant(ctx, req.(*LeaseGrantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Leases_Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaseQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeasesServer).Query(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ptarmiganpb.Leases/Query",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeasesServer).Query(ctx, req.(*LeaseQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Leases_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaseGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeasesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ptarmiganpb.Leases/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeasesServer).Get(ctx, req.(*LeaseGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Leases_Revoke_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaseRevokeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeasesServer).Revoke(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ptarmiganpb.Leases/Revoke",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeasesServer).Revoke(ctx, req.(*LeaseRevokeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Leases_Renew_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaseRenewRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeasesServer).Renew(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ptarmiganpb.Leases/Renew",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeasesServer).Renew(ctx, req.(*LeaseRenewRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Leases_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ptarmiganpb.Leases",
	HandlerType: (*LeasesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Grant",
			Handler:    _Leases_Grant_Handler,
		},
		{
			MethodName: "Query",
			Handler:    _Leases_Query_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Leases_Get_Handler,
		},
		{
			MethodName: "Revoke",
			Handler:    _Leases_Revoke_Handler,
		},
		{
			MethodName: "Renew",
			Handler:    _Leases_Renew_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc.proto",
}

func (m *PartitionRequestHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionRequestHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionRequestHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Replica) > 0 {
		i -= len(m.Replica)
		copy(dAtA[i:], m.Replica)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Replica)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Partition) > 0 {
		i -= len(m.Partition)
		copy(dAtA[i:], m.Partition)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Partition)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Store) > 0 {
		i -= len(m.Store)
		copy(dAtA[i:], m.Store)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Store)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResponseHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MemberId != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.MemberId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *KVPredicate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVPredicate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVPredicate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Field != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.Field))
		i--
		dAtA[i] = 0x10
	}
	if m.Operator != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.Operator))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *KVPredicate_Int64) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVPredicate_Int64) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintRpc(dAtA, i, uint64(m.Int64))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *KVPredicate_Bytes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVPredicate_Bytes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Bytes != nil {
		i -= len(m.Bytes)
		copy(dAtA[i:], m.Bytes)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Bytes)))
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *KVQueryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVQueryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVQueryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IncludeCount {
		i--
		if m.IncludeCount {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.ExcludeValues {
		i--
		if m.ExcludeValues {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Serializable {
		i--
		if m.Serializable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.SortTarget != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.SortTarget))
		i--
		dAtA[i] = 0x38
	}
	if m.SortOrder != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.SortOrder))
		i--
		dAtA[i] = 0x30
	}
	if m.Revision != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.Revision))
		i--
		dAtA[i] = 0x28
	}
	if m.Limit != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x20
	}
	if len(m.After) > 0 {
		i -= len(m.After)
		copy(dAtA[i:], m.After)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.After)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Selection) > 0 {
		for iNdEx := len(m.Selection) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Selection[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *KVQueryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVQueryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVQueryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x28
	}
	if len(m.After) > 0 {
		i -= len(m.After)
		copy(dAtA[i:], m.After)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.After)))
		i--
		dAtA[i] = 0x22
	}
	if m.More {
		i--
		if m.More {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Kvs) > 0 {
		for iNdEx := len(m.Kvs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Kvs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *KVPutRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVPutRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVPutRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IgnoreLease {
		i--
		if m.IgnoreLease {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.IgnoreValue {
		i--
		if m.IgnoreValue {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.PrevKv {
		i--
		if m.PrevKv {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Lease != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.Lease))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Selection) > 0 {
		for iNdEx := len(m.Selection) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Selection[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *KVPutResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVPutResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVPutResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PrevKvs) > 0 {
		for iNdEx := len(m.PrevKvs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PrevKvs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *KVDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PrevKv {
		i--
		if m.PrevKv {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Selection) > 0 {
		for iNdEx := len(m.Selection) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Selection[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *KVDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVDeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PrevKvs) > 0 {
		for iNdEx := len(m.PrevKvs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PrevKvs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Deleted != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.Deleted))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *KVRequestOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVRequestOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVRequestOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Request != nil {
		{
			size := m.Request.Size()
			i -= size
			if _, err := m.Request.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *KVRequestOp_RequestQuery) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVRequestOp_RequestQuery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RequestQuery != nil {
		{
			size, err := m.RequestQuery.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *KVRequestOp_RequestPut) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVRequestOp_RequestPut) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RequestPut != nil {
		{
			size, err := m.RequestPut.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *KVRequestOp_RequestDelete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVRequestOp_RequestDelete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RequestDelete != nil {
		{
			size, err := m.RequestDelete.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *KVRequestOp_RequestTxn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVRequestOp_RequestTxn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RequestTxn != nil {
		{
			size, err := m.RequestTxn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *KVResponseOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVResponseOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVResponseOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Response != nil {
		{
			size := m.Response.Size()
			i -= size
			if _, err := m.Response.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *KVResponseOp_ResponseQuery) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVResponseOp_ResponseQuery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ResponseQuery != nil {
		{
			size, err := m.ResponseQuery.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *KVResponseOp_ResponsePut) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVResponseOp_ResponsePut) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ResponsePut != nil {
		{
			size, err := m.ResponsePut.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *KVResponseOp_ResponseDelete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVResponseOp_ResponseDelete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ResponseDelete != nil {
		{
			size, err := m.ResponseDelete.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *KVResponseOp_ResponseTxn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVResponseOp_ResponseTxn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ResponseTxn != nil {
		{
			size, err := m.ResponseTxn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Condition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Condition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Condition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Quantifier != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.Quantifier))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Predicate.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Domain) > 0 {
		for iNdEx := len(m.Domain) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Domain[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *KVTxnRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVTxnRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVTxnRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Failure) > 0 {
		for iNdEx := len(m.Failure) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Failure[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Success) > 0 {
		for iNdEx := len(m.Success) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Success[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *KVTxnResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVTxnResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVTxnResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Responses) > 0 {
		for iNdEx := len(m.Responses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Responses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Succeeded {
		i--
		if m.Succeeded {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *KVCompactionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVCompactionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVCompactionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Revision != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.Revision))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *KVCompactionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVCompactionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVCompactionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *KVWatchCursor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVWatchCursor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVWatchCursor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if m.Revision != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.Revision))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *KeyRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x8a
	}
	if len(m.KeyStartsWith) > 0 {
		i -= len(m.KeyStartsWith)
		copy(dAtA[i:], m.KeyStartsWith)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.KeyStartsWith)))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x82
	}
	if m.KeyRangeMax != nil {
		{
			size := m.KeyRangeMax.Size()
			i -= size
			if _, err := m.KeyRangeMax.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.KeyRangeMin != nil {
		{
			size := m.KeyRangeMin.Size()
			i -= size
			if _, err := m.KeyRangeMin.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *KeyRange_KeyGt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyRange_KeyGt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.KeyGt != nil {
		i -= len(m.KeyGt)
		copy(dAtA[i:], m.KeyGt)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.KeyGt)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *KeyRange_KeyGte) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyRange_KeyGte) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.KeyGte != nil {
		i -= len(m.KeyGte)
		copy(dAtA[i:], m.KeyGte)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.KeyGte)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *KeyRange_KeyLt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyRange_KeyLt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.KeyLt != nil {
		i -= len(m.KeyLt)
		copy(dAtA[i:], m.KeyLt)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.KeyLt)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *KeyRange_KeyLte) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyRange_KeyLte) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.KeyLte != nil {
		i -= len(m.KeyLte)
		copy(dAtA[i:], m.KeyLte)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.KeyLte)))
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *KVWatchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVWatchRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVWatchRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PrevKv {
		i--
		if m.PrevKv {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.NoDelete {
		i--
		if m.NoDelete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.NoPut {
		i--
		if m.NoPut {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.ProgressNotify {
		i--
		if m.ProgressNotify {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Keys.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Start.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *KVWatchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVWatchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVWatchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Events[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	{
		size, err := m.After.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.CancelReason) > 0 {
		i -= len(m.CancelReason)
		copy(dAtA[i:], m.CancelReason)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.CancelReason)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Compacted {
		i--
		if m.Compacted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LeaseGrantRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaseGrantRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaseGrantRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TTL != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.TTL))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LeaseGrantResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaseGrantResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaseGrantResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Lease.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LeaseRevokeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaseRevokeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaseRevokeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LeaseRevokeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaseRevokeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaseRevokeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LeaseRenewRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaseRenewRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaseRenewRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LeaseRenewResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaseRenewResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaseRenewResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Lease.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LeaseGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaseGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaseGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LeaseGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaseGetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaseGetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Lease.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LeaseQueryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaseQueryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaseQueryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LeaseQueryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaseQueryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaseQueryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Leases) > 0 {
		for iNdEx := len(m.Leases) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Leases[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *KeyValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Lease != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.Lease))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Version != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x20
	}
	if m.ModRevision != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.ModRevision))
		i--
		dAtA[i] = 0x18
	}
	if m.CreateRevision != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.CreateRevision))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PrevKv != nil {
		{
			size, err := m.PrevKv.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Kv.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Type != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Lease) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Lease) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Lease) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GrantedTTL != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.GrantedTTL))
		i--
		dAtA[i] = 0x20
	}
	if m.TTL != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.TTL))
		i--
		dAtA[i] = 0x18
	}
	if m.ID != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func encodeVarintRpc(dAtA []byte, offset int, v uint64) int {
	offset -= sovRpc(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PartitionRequestHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Store)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.Partition)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.Replica)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	return n
}

func (m *ResponseHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemberId != 0 {
		n += 1 + sovRpc(uint64(m.MemberId))
	}
	return n
}

func (m *KVPredicate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Operator != 0 {
		n += 1 + sovRpc(uint64(m.Operator))
	}
	if m.Field != 0 {
		n += 1 + sovRpc(uint64(m.Field))
	}
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *KVPredicate_Int64) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovRpc(uint64(m.Int64))
	return n
}
func (m *KVPredicate_Bytes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bytes != nil {
		l = len(m.Bytes)
		n += 1 + l + sovRpc(uint64(l))
	}
	return n
}
func (m *KVQueryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovRpc(uint64(l))
	if len(m.Selection) > 0 {
		for _, e := range m.Selection {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	l = len(m.After)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovRpc(uint64(m.Limit))
	}
	if m.Revision != 0 {
		n += 1 + sovRpc(uint64(m.Revision))
	}
	if m.SortOrder != 0 {
		n += 1 + sovRpc(uint64(m.SortOrder))
	}
	if m.SortTarget != 0 {
		n += 1 + sovRpc(uint64(m.SortTarget))
	}
	if m.Serializable {
		n += 2
	}
	if m.ExcludeValues {
		n += 2
	}
	if m.IncludeCount {
		n += 2
	}
	return n
}

func (m *KVQueryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovRpc(uint64(l))
	if len(m.Kvs) > 0 {
		for _, e := range m.Kvs {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.More {
		n += 2
	}
	l = len(m.After)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovRpc(uint64(m.Count))
	}
	return n
}

func (m *KVPutRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovRpc(uint64(l))
	if len(m.Selection) > 0 {
		for _, e := range m.Selection {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.Lease != 0 {
		n += 1 + sovRpc(uint64(m.Lease))
	}
	if m.PrevKv {
		n += 2
	}
	if m.IgnoreValue {
		n += 2
	}
	if m.IgnoreLease {
		n += 2
	}
	return n
}

func (m *KVPutResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovRpc(uint64(l))
	if len(m.PrevKvs) > 0 {
		for _, e := range m.PrevKvs {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	return n
}

func (m *KVDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovRpc(uint64(l))
	if len(m.Selection) > 0 {
		for _, e := range m.Selection {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.PrevKv {
		n += 2
	}
	return n
}

func (m *KVDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovRpc(uint64(l))
	if m.Deleted != 0 {
		n += 1 + sovRpc(uint64(m.Deleted))
	}
	if len(m.PrevKvs) > 0 {
		for _, e := range m.PrevKvs {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	return n
}

func (m *KVRequestOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		n += m.Request.Size()
	}
	return n
}

func (m *KVRequestOp_RequestQuery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestQuery != nil {
		l = m.RequestQuery.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	return n
}
func (m *KVRequestOp_RequestPut) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestPut != nil {
		l = m.RequestPut.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	return n
}
func (m *KVRequestOp_RequestDelete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestDelete != nil {
		l = m.RequestDelete.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	return n
}
func (m *KVRequestOp_RequestTxn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestTxn != nil {
		l = m.RequestTxn.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	return n
}
func (m *KVResponseOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Response != nil {
		n += m.Response.Size()
	}
	return n
}

func (m *KVResponseOp_ResponseQuery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResponseQuery != nil {
		l = m.ResponseQuery.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	return n
}
func (m *KVResponseOp_ResponsePut) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResponsePut != nil {
		l = m.ResponsePut.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	return n
}
func (m *KVResponseOp_ResponseDelete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResponseDelete != nil {
		l = m.ResponseDelete.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	return n
}
func (m *KVResponseOp_ResponseTxn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResponseTxn != nil {
		l = m.ResponseTxn.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	return n
}
func (m *Condition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Domain) > 0 {
		for _, e := range m.Domain {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	l = m.Predicate.Size()
	n += 1 + l + sovRpc(uint64(l))
	if m.Quantifier != 0 {
		n += 1 + sovRpc(uint64(m.Quantifier))
	}
	return n
}

func (m *KVTxnRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovRpc(uint64(l))
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if len(m.Success) > 0 {
		for _, e := range m.Success {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if len(m.Failure) > 0 {
		for _, e := range m.Failure {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	return n
}

func (m *KVTxnResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovRpc(uint64(l))
	if m.Succeeded {
		n += 2
	}
	if len(m.Responses) > 0 {
		for _, e := range m.Responses {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	return n
}

func (m *KVCompactionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovRpc(uint64(l))
	if m.Revision != 0 {
		n += 1 + sovRpc(uint64(m.Revision))
	}
	return n
}

func (m *KVCompactionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovRpc(uint64(l))
	return n
}

func (m *KVWatchCursor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Revision != 0 {
		n += 1 + sovRpc(uint64(m.Revision))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	return n
}

func (m *KeyRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeyRangeMin != nil {
		n += m.KeyRangeMin.Size()
	}
	if m.KeyRangeMax != nil {
		n += m.KeyRangeMax.Size()
	}
	l = len(m.KeyStartsWith)
	if l > 0 {
		n += 2 + l + sovRpc(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 2 + l + sovRpc(uint64(l))
	}
	return n
}

func (m *KeyRange_KeyGt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeyGt != nil {
		l = len(m.KeyGt)
		n += 1 + l + sovRpc(uint64(l))
	}
	return n
}
func (m *KeyRange_KeyGte) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeyGte != nil {
		l = len(m.KeyGte)
		n += 1 + l + sovRpc(uint64(l))
	}
	return n
}
func (m *KeyRange_KeyLt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeyLt != nil {
		l = len(m.KeyLt)
		n += 1 + l + sovRpc(uint64(l))
	}
	return n
}
func (m *KeyRange_KeyLte) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeyLte != nil {
		l = len(m.KeyLte)
		n += 1 + l + sovRpc(uint64(l))
	}
	return n
}
func (m *KVWatchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovRpc(uint64(l))
	l = m.Start.Size()
	n += 1 + l + sovRpc(uint64(l))
	l = m.Keys.Size()
	n += 1 + l + sovRpc(uint64(l))
	if m.ProgressNotify {
		n += 2
	}
	if m.NoPut {
		n += 2
	}
	if m.NoDelete {
		n += 2
	}
	if m.PrevKv {
		n += 2
	}
	return n
}

func (m *KVWatchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovRpc(uint64(l))
	if m.Compacted {
		n += 2
	}
	l = len(m.CancelReason)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = m.After.Size()
	n += 1 + l + sovRpc(uint64(l))
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	return n
}

func (m *LeaseGrantRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovRpc(uint64(l))
	if m.TTL != 0 {
		n += 1 + sovRpc(uint64(m.TTL))
	}
	return n
}

func (m *LeaseGrantResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovRpc(uint64(l))
	l = m.Lease.Size()
	n += 1 + l + sovRpc(uint64(l))
	return n
}

func (m *LeaseRevokeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovRpc(uint64(l))
	if m.ID != 0 {
		n += 1 + sovRpc(uint64(m.ID))
	}
	return n
}

func (m *LeaseRevokeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovRpc(uint64(l))
	return n
}

func (m *LeaseRenewRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovRpc(uint64(l))
	if m.ID != 0 {
		n += 1 + sovRpc(uint64(m.ID))
	}
	return n
}

func (m *LeaseRenewResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovRpc(uint64(l))
	l = m.Lease.Size()
	n += 1 + l + sovRpc(uint64(l))
	return n
}

func (m *LeaseGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovRpc(uint64(l))
	if m.ID != 0 {
		n += 1 + sovRpc(uint64(m.ID))
	}
	return n
}

func (m *LeaseGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovRpc(uint64(l))
	l = m.Lease.Size()
	n += 1 + l + sovRpc(uint64(l))
	return n
}

func (m *LeaseQueryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovRpc(uint64(l))
	return n
}

func (m *LeaseQueryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovRpc(uint64(l))
	if len(m.Leases) > 0 {
		for _, e := range m.Leases {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	return n
}

func (m *KeyValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.CreateRevision != 0 {
		n += 1 + sovRpc(uint64(m.CreateRevision))
	}
	if m.ModRevision != 0 {
		n += 1 + sovRpc(uint64(m.ModRevision))
	}
	if m.Version != 0 {
		n += 1 + sovRpc(uint64(m.Version))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.Lease != 0 {
		n += 1 + sovRpc(uint64(m.Lease))
	}
	return n
}

func (m *Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovRpc(uint64(m.Type))
	}
	l = m.Kv.Size()
	n += 1 + l + sovRpc(uint64(l))
	if m.PrevKv != nil {
		l = m.PrevKv.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	return n
}

func (m *Lease) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovRpc(uint64(m.ID))
	}
	if m.TTL != 0 {
		n += 1 + sovRpc(uint64(m.TTL))
	}
	if m.GrantedTTL != 0 {
		n += 1 + sovRpc(uint64(m.GrantedTTL))
	}
	return n
}

func sovRpc(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRpc(x uint64) (n int) {
	return sovRpc(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PartitionRequestHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionRequestHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionRequestHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Store", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Store = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replica = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberId", wireType)
			}
			m.MemberId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVPredicate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVPredicate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVPredicate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			m.Operator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operator |= KVPredicate_Operator(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			m.Field = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Field |= Field(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &KVPredicate_Int64{v}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Value = &KVPredicate_Bytes{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVQueryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVQueryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVQueryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Selection = append(m.Selection, KVPredicate{})
			if err := m.Selection[len(m.Selection)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field After", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.After = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			m.Revision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Revision |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortOrder", wireType)
			}
			m.SortOrder = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SortOrder |= KVQueryRequest_SortOrder(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortTarget", wireType)
			}
			m.SortTarget = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SortTarget |= Field(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Serializable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Serializable = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeValues", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExcludeValues = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeCount", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeCount = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVQueryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVQueryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVQueryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kvs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kvs = append(m.Kvs, KeyValue{})
			if err := m.Kvs[len(m.Kvs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field More", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.More = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field After", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.After = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVPutRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVPutRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVPutRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Selection = append(m.Selection, KVPredicate{})
			if err := m.Selection[len(m.Selection)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lease", wireType)
			}
			m.Lease = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lease |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevKv", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PrevKv = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreValue = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreLease", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreLease = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVPutResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVPutResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVPutResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevKvs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrevKvs = append(m.PrevKvs, KeyValue{})
			if err := m.PrevKvs[len(m.PrevKvs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Selection = append(m.Selection, KVPredicate{})
			if err := m.Selection[len(m.Selection)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevKv", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PrevKv = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deleted", wireType)
			}
			m.Deleted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Deleted |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevKvs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrevKvs = append(m.PrevKvs, KeyValue{})
			if err := m.PrevKvs[len(m.PrevKvs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVRequestOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVRequestOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVRequestOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestQuery", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &KVQueryRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &KVRequestOp_RequestQuery{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestPut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &KVPutRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &KVRequestOp_RequestPut{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestDelete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &KVDeleteRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &KVRequestOp_RequestDelete{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &KVTxnRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &KVRequestOp_RequestTxn{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVResponseOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVResponseOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVResponseOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseQuery", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &KVQueryResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &KVResponseOp_ResponseQuery{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponsePut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &KVPutResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &KVResponseOp_ResponsePut{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseDelete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &KVDeleteResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &KVResponseOp_ResponseDelete{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &KVTxnResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &KVResponseOp_ResponseTxn{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Condition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Condition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Condition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = append(m.Domain, KVPredicate{})
			if err := m.Domain[len(m.Domain)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Predicate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantifier", wireType)
			}
			m.Quantifier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quantifier |= Condition_Quantifier(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVTxnRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVTxnRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVTxnRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, Condition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Success = append(m.Success, KVRequestOp{})
			if err := m.Success[len(m.Success)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Failure = append(m.Failure, KVRequestOp{})
			if err := m.Failure[len(m.Failure)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVTxnResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVTxnResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVTxnResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Succeeded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Succeeded = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Responses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Responses = append(m.Responses, KVResponseOp{})
			if err := m.Responses[len(m.Responses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVCompactionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVCompactionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVCompactionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			m.Revision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Revision |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVCompactionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVCompactionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVCompactionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVWatchCursor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVWatchCursor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVWatchCursor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			m.Revision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Revision |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyGt", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.KeyRangeMin = &KeyRange_KeyGt{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyGte", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.KeyRangeMin = &KeyRange_KeyGte{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyLt", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.KeyRangeMax = &KeyRange_KeyLt{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyLte", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.KeyRangeMax = &KeyRange_KeyLte{v}
			iNdEx = postIndex
		case 64:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyStartsWith", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyStartsWith = append(m.KeyStartsWith[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyStartsWith == nil {
				m.KeyStartsWith = []byte{}
			}
			iNdEx = postIndex
		case 65:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVWatchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVWatchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVWatchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Keys.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgressNotify", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ProgressNotify = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoPut", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoPut = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoDelete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoDelete = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevKv", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PrevKv = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVWatchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVWatchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVWatchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compacted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Compacted = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CancelReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field After", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.After.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, Event{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaseGrantRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaseGrantRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaseGrantRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			m.TTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTL |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaseGrantResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaseGrantResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaseGrantResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Lease.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaseRevokeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaseRevokeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaseRevokeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaseRevokeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaseRevokeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaseRevokeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaseRenewRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaseRenewRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaseRenewRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaseRenewResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaseRenewResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaseRenewResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Lease.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaseGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaseGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaseGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaseGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaseGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaseGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Lease.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaseQueryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaseQueryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaseQueryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaseQueryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaseQueryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaseQueryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leases", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leases = append(m.Leases, Lease{})
			if err := m.Leases[len(m.Leases)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateRevision", wireType)
			}
			m.CreateRevision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateRevision |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModRevision", wireType)
			}
			m.ModRevision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModRevision |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lease", wireType)
			}
			m.Lease = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lease |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Event_EventType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Kv.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevKv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrevKv == nil {
				m.PrevKv = &KeyValue{}
			}
			if err := m.PrevKv.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Lease) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Lease: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Lease: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			m.TTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTL |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrantedTTL", wireType)
			}
			m.GrantedTTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GrantedTTL |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRpc(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRpc
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRpc
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRpc
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRpc        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRpc          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRpc = fmt.Errorf("proto: unexpected end of group")
)
